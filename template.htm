<html>
<head>
  <!-- This file is the boilerplate needed to create an interface using interface.js
  <script src="zepto.js"></script> -->
  <script>
  (function(a){String.prototype.trim===a&&(String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g,"")}),Array.prototype.reduce===a&&(Array.prototype.reduce=function(b){if(this===void 0||this===null)throw new TypeError;var c=Object(this),d=c.length>>>0,e=0,f;if(typeof b!="function")throw new TypeError;if(d==0&&arguments.length==1)throw new TypeError;if(arguments.length>=2)f=arguments[1];else do{if(e in c){f=c[e++];break}if(++e>=d)throw new TypeError}while(!0);while(e<d)e in c&&(f=b.call(a,f,c[e],e,c)),e++;return f})})();var Zepto=function(){function E(a){return a==null?String(a):y[z.call(a)]||"object"}function F(a){return E(a)=="function"}function G(a){return a!=null&&a==a.window}function H(a){return a!=null&&a.nodeType==a.DOCUMENT_NODE}function I(a){return E(a)=="object"}function J(a){return I(a)&&!G(a)&&a.__proto__==Object.prototype}function K(a){return a instanceof Array}function L(a){return typeof a.length=="number"}function M(a){return g.call(a,function(a){return a!=null})}function N(a){return a.length>0?c.fn.concat.apply([],a):a}function O(a){return a.replace(/::/g,"/").replace(/([A-Z]+)([A-Z][a-z])/g,"$1_$2").replace(/([a-z\d])([A-Z])/g,"$1_$2").replace(/_/g,"-").toLowerCase()}function P(a){return a in j?j[a]:j[a]=new RegExp("(^|\\s)"+a+"(\\s|$)")}function Q(a,b){return typeof b=="number"&&!l[O(a)]?b+"px":b}function R(a){var b,c;return i[a]||(b=h.createElement(a),h.body.appendChild(b),c=k(b,"").getPropertyValue("display"),b.parentNode.removeChild(b),c=="none"&&(c="block"),i[a]=c),i[a]}function S(a){return"children"in a?f.call(a.children):c.map(a.childNodes,function(a){if(a.nodeType==1)return a})}function T(c,d,e){for(b in d)e&&(J(d[b])||K(d[b]))?(J(d[b])&&!J(c[b])&&(c[b]={}),K(d[b])&&!K(c[b])&&(c[b]=[]),T(c[b],d[b],e)):d[b]!==a&&(c[b]=d[b])}function U(b,d){return d===a?c(b):c(b).filter(d)}function V(a,b,c,d){return F(b)?b.call(a,c,d):b}function W(a,b,c){c==null?a.removeAttribute(b):a.setAttribute(b,c)}function X(b,c){var d=b.className,e=d&&d.baseVal!==a;if(c===a)return e?d.baseVal:d;e?d.baseVal=c:b.className=c}function Y(a){var b;try{return a?a=="true"||(a=="false"?!1:a=="null"?null:isNaN(b=Number(a))?/^[\[\{]/.test(a)?c.parseJSON(a):a:b):a}catch(d){return a}}function Z(a,b){b(a);for(var c in a.childNodes)Z(a.childNodes[c],b)}var a,b,c,d,e=[],f=e.slice,g=e.filter,h=window.document,i={},j={},k=h.defaultView.getComputedStyle,l={"column-count":1,columns:1,"font-weight":1,"line-height":1,opacity:1,"z-index":1,zoom:1},m=/^\s*<(\w+|!)[^>]*>/,n=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,o=/^(?:body|html)$/i,p=["val","css","html","text","data","width","height","offset"],q=["after","prepend","before","append"],r=h.createElement("table"),s=h.createElement("tr"),t={tr:h.createElement("tbody"),tbody:r,thead:r,tfoot:r,td:s,th:s,"*":h.createElement("div")},u=/complete|loaded|interactive/,v=/^\.([\w-]+)$/,w=/^#([\w-]*)$/,x=/^[\w-]+$/,y={},z=y.toString,A={},B,C,D=h.createElement("div");return A.matches=function(a,b){if(!a||a.nodeType!==1)return!1;var c=a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.matchesSelector;if(c)return c.call(a,b);var d,e=a.parentNode,f=!e;return f&&(e=D).appendChild(a),d=~A.qsa(e,b).indexOf(a),f&&D.removeChild(a),d},B=function(a){return a.replace(/-+(.)?/g,function(a,b){return b?b.toUpperCase():""})},C=function(a){return g.call(a,function(b,c){return a.indexOf(b)==c})},A.fragment=function(b,d,e){b.replace&&(b=b.replace(n,"<$1></$2>")),d===a&&(d=m.test(b)&&RegExp.$1),d in t||(d="*");var g,h,i=t[d];return i.innerHTML=""+b,h=c.each(f.call(i.childNodes),function(){i.removeChild(this)}),J(e)&&(g=c(h),c.each(e,function(a,b){p.indexOf(a)>-1?g[a](b):g.attr(a,b)})),h},A.Z=function(a,b){return a=a||[],a.__proto__=c.fn,a.selector=b||"",a},A.isZ=function(a){return a instanceof A.Z},A.init=function(b,d){if(!b)return A.Z();if(F(b))return c(h).ready(b);if(A.isZ(b))return b;var e;if(K(b))e=M(b);else if(I(b))e=[J(b)?c.extend({},b):b],b=null;else if(m.test(b))e=A.fragment(b.trim(),RegExp.$1,d),b=null;else{if(d!==a)return c(d).find(b);e=A.qsa(h,b)}return A.Z(e,b)},c=function(a,b){return A.init(a,b)},c.extend=function(a){var b,c=f.call(arguments,1);return typeof a=="boolean"&&(b=a,a=c.shift()),c.forEach(function(c){T(a,c,b)}),a},A.qsa=function(a,b){var c;return H(a)&&w.test(b)?(c=a.getElementById(RegExp.$1))?[c]:[]:a.nodeType!==1&&a.nodeType!==9?[]:f.call(v.test(b)?a.getElementsByClassName(RegExp.$1):x.test(b)?a.getElementsByTagName(b):a.querySelectorAll(b))},c.contains=function(a,b){return a!==b&&a.contains(b)},c.type=E,c.isFunction=F,c.isWindow=G,c.isArray=K,c.isPlainObject=J,c.isEmptyObject=function(a){var b;for(b in a)return!1;return!0},c.inArray=function(a,b,c){return e.indexOf.call(b,a,c)},c.camelCase=B,c.trim=function(a){return a.trim()},c.uuid=0,c.support={},c.expr={},c.map=function(a,b){var c,d=[],e,f;if(L(a))for(e=0;e<a.length;e++)c=b(a[e],e),c!=null&&d.push(c);else for(f in a)c=b(a[f],f),c!=null&&d.push(c);return N(d)},c.each=function(a,b){var c,d;if(L(a)){for(c=0;c<a.length;c++)if(b.call(a[c],c,a[c])===!1)return a}else for(d in a)if(b.call(a[d],d,a[d])===!1)return a;return a},c.grep=function(a,b){return g.call(a,b)},window.JSON&&(c.parseJSON=JSON.parse),c.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){y["[object "+b+"]"]=b.toLowerCase()}),c.fn={forEach:e.forEach,reduce:e.reduce,push:e.push,sort:e.sort,indexOf:e.indexOf,concat:e.concat,map:function(a){return c(c.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return c(f.apply(this,arguments))},ready:function(a){return u.test(h.readyState)?a(c):h.addEventListener("DOMContentLoaded",function(){a(c)},!1),this},get:function(b){return b===a?f.call(this):this[b>=0?b:b+this.length]},toArray:function(){return this.get()},size:function(){return this.length},remove:function(){return this.each(function(){this.parentNode!=null&&this.parentNode.removeChild(this)})},each:function(a){return e.every.call(this,function(b,c){return a.call(b,c,b)!==!1}),this},filter:function(a){return F(a)?this.not(this.not(a)):c(g.call(this,function(b){return A.matches(b,a)}))},add:function(a,b){return c(C(this.concat(c(a,b))))},is:function(a){return this.length>0&&A.matches(this[0],a)},not:function(b){var d=[];if(F(b)&&b.call!==a)this.each(function(a){b.call(this,a)||d.push(this)});else{var e=typeof b=="string"?this.filter(b):L(b)&&F(b.item)?f.call(b):c(b);this.forEach(function(a){e.indexOf(a)<0&&d.push(a)})}return c(d)},has:function(a){return this.filter(function(){return I(a)?c.contains(this,a):c(this).find(a).size()})},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){var a=this[0];return a&&!I(a)?a:c(a)},last:function(){var a=this[this.length-1];return a&&!I(a)?a:c(a)},find:function(a){var b,d=this;return typeof a=="object"?b=c(a).filter(function(){var a=this;return e.some.call(d,function(b){return c.contains(b,a)})}):this.length==1?b=c(A.qsa(this[0],a)):b=this.map(function(){return A.qsa(this,a)}),b},closest:function(a,b){var d=this[0],e=!1;typeof a=="object"&&(e=c(a));while(d&&!(e?e.indexOf(d)>=0:A.matches(d,a)))d=d!==b&&!H(d)&&d.parentNode;return c(d)},parents:function(a){var b=[],d=this;while(d.length>0)d=c.map(d,function(a){if((a=a.parentNode)&&!H(a)&&b.indexOf(a)<0)return b.push(a),a});return U(b,a)},parent:function(a){return U(C(this.pluck("parentNode")),a)},children:function(a){return U(this.map(function(){return S(this)}),a)},contents:function(){return this.map(function(){return f.call(this.childNodes)})},siblings:function(a){return U(this.map(function(a,b){return g.call(S(b.parentNode),function(a){return a!==b})}),a)},empty:function(){return this.each(function(){this.innerHTML=""})},pluck:function(a){return c.map(this,function(b){return b[a]})},show:function(){return this.each(function(){this.style.display=="none"&&(this.style.display=null),k(this,"").getPropertyValue("display")=="none"&&(this.style.display=R(this.nodeName))})},replaceWith:function(a){return this.before(a).remove()},wrap:function(a){var b=F(a);if(this[0]&&!b)var d=c(a).get(0),e=d.parentNode||this.length>1;return this.each(function(f){c(this).wrapAll(b?a.call(this,f):e?d.cloneNode(!0):d)})},wrapAll:function(a){if(this[0]){c(this[0]).before(a=c(a));var b;while((b=a.children()).length)a=b.first();c(a).append(this)}return this},wrapInner:function(a){var b=F(a);return this.each(function(d){var e=c(this),f=e.contents(),g=b?a.call(this,d):a;f.length?f.wrapAll(g):e.append(g)})},unwrap:function(){return this.parent().each(function(){c(this).replaceWith(c(this).children())}),this},clone:function(){return this.map(function(){return this.cloneNode(!0)})},hide:function(){return this.css("display","none")},toggle:function(b){return this.each(function(){var d=c(this);(b===a?d.css("display")=="none":b)?d.show():d.hide()})},prev:function(a){return c(this.pluck("previousElementSibling")).filter(a||"*")},next:function(a){return c(this.pluck("nextElementSibling")).filter(a||"*")},html:function(b){return b===a?this.length>0?this[0].innerHTML:null:this.each(function(a){var d=this.innerHTML;c(this).empty().append(V(this,b,a,d))})},text:function(b){return b===a?this.length>0?this[0].textContent:null:this.each(function(){this.textContent=b})},attr:function(c,d){var e;return typeof c=="string"&&d===a?this.length==0||this[0].nodeType!==1?a:c=="value"&&this[0].nodeName=="INPUT"?this.val():!(e=this[0].getAttribute(c))&&c in this[0]?this[0][c]:e:this.each(function(a){if(this.nodeType!==1)return;if(I(c))for(b in c)W(this,b,c[b]);else W(this,c,V(this,d,a,this.getAttribute(c)))})},removeAttr:function(a){return this.each(function(){this.nodeType===1&&W(this,a)})},prop:function(b,c){return c===a?this[0]&&this[0][b]:this.each(function(a){this[b]=V(this,c,a,this[b])})},data:function(b,c){var d=this.attr("data-"+O(b),c);return d!==null?Y(d):a},val:function(b){return b===a?this[0]&&(this[0].multiple?c(this[0]).find("option").filter(function(a){return this.selected}).pluck("value"):this[0].value):this.each(function(a){this.value=V(this,b,a,this.value)})},offset:function(a){if(a)return this.each(function(b){var d=c(this),e=V(this,a,b,d.offset()),f=d.offsetParent().offset(),g={top:e.top-f.top,left:e.left-f.left};d.css("position")=="static"&&(g.position="relative"),d.css(g)});if(this.length==0)return null;var b=this[0].getBoundingClientRect();return{left:b.left+window.pageXOffset,top:b.top+window.pageYOffset,width:Math.round(b.width),height:Math.round(b.height)}},css:function(a,c){if(arguments.length<2&&typeof a=="string")return this[0]&&(this[0].style[B(a)]||k(this[0],"").getPropertyValue(a));var d="";if(E(a)=="string")!c&&c!==0?this.each(function(){this.style.removeProperty(O(a))}):d=O(a)+":"+Q(a,c);else for(b in a)!a[b]&&a[b]!==0?this.each(function(){this.style.removeProperty(O(b))}):d+=O(b)+":"+Q(b,a[b])+";";return this.each(function(){this.style.cssText+=";"+d})},index:function(a){return a?this.indexOf(c(a)[0]):this.parent().children().indexOf(this[0])},hasClass:function(a){return e.some.call(this,function(a){return this.test(X(a))},P(a))},addClass:function(a){return this.each(function(b){d=[];var e=X(this),f=V(this,a,b,e);f.split(/\s+/g).forEach(function(a){c(this).hasClass(a)||d.push(a)},this),d.length&&X(this,e+(e?" ":"")+d.join(" "))})},removeClass:function(b){return this.each(function(c){if(b===a)return X(this,"");d=X(this),V(this,b,c,d).split(/\s+/g).forEach(function(a){d=d.replace(P(a)," ")}),X(this,d.trim())})},toggleClass:function(b,d){return this.each(function(e){var f=c(this),g=V(this,b,e,X(this));g.split(/\s+/g).forEach(function(b){(d===a?!f.hasClass(b):d)?f.addClass(b):f.removeClass(b)})})},scrollTop:function(){if(!this.length)return;return"scrollTop"in this[0]?this[0].scrollTop:this[0].scrollY},position:function(){if(!this.length)return;var a=this[0],b=this.offsetParent(),d=this.offset(),e=o.test(b[0].nodeName)?{top:0,left:0}:b.offset();return d.top-=parseFloat(c(a).css("margin-top"))||0,d.left-=parseFloat(c(a).css("margin-left"))||0,e.top+=parseFloat(c(b[0]).css("border-top-width"))||0,e.left+=parseFloat(c(b[0]).css("border-left-width"))||0,{top:d.top-e.top,left:d.left-e.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||h.body;while(a&&!o.test(a.nodeName)&&c(a).css("position")=="static")a=a.offsetParent;return a})}},c.fn.detach=c.fn.remove,["width","height"].forEach(function(b){c.fn[b]=function(d){var e,f=this[0],g=b.replace(/./,function(a){return a[0].toUpperCase()});return d===a?G(f)?f["inner"+g]:H(f)?f.documentElement["offset"+g]:(e=this.offset())&&e[b]:this.each(function(a){f=c(this),f.css(b,V(this,d,a,f[b]()))})}}),q.forEach(function(a,b){var d=b%2;c.fn[a]=function(){var a,e=c.map(arguments,function(b){return a=E(b),a=="object"||a=="array"||b==null?b:A.fragment(b)}),f,g=this.length>1;return e.length<1?this:this.each(function(a,h){f=d?h:h.parentNode,h=b==0?h.nextSibling:b==1?h.firstChild:b==2?h:null,e.forEach(function(a){if(g)a=a.cloneNode(!0);else if(!f)return c(a).remove();Z(f.insertBefore(a,h),function(a){a.nodeName!=null&&a.nodeName.toUpperCase()==="SCRIPT"&&(!a.type||a.type==="text/javascript")&&!a.src&&window.eval.call(window,a.innerHTML)})})})},c.fn[d?a+"To":"insert"+(b?"Before":"After")]=function(b){return c(b)[a](this),this}}),A.Z.prototype=c.fn,A.uniq=C,A.deserializeValue=Y,c.zepto=A,c}();window.Zepto=Zepto,"$"in window||(window.$=Zepto),function(a){function b(a){var b=this.os={},c=this.browser={},d=a.match(/WebKit\/([\d.]+)/),e=a.match(/(Android)\s+([\d.]+)/),f=a.match(/(iPad).*OS\s([\d_]+)/),g=!f&&a.match(/(iPhone\sOS)\s([\d_]+)/),h=a.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),i=h&&a.match(/TouchPad/),j=a.match(/Kindle\/([\d.]+)/),k=a.match(/Silk\/([\d._]+)/),l=a.match(/(BlackBerry).*Version\/([\d.]+)/),m=a.match(/(BB10).*Version\/([\d.]+)/),n=a.match(/(RIM\sTablet\sOS)\s([\d.]+)/),o=a.match(/PlayBook/),p=a.match(/Chrome\/([\d.]+)/)||a.match(/CriOS\/([\d.]+)/),q=a.match(/Firefox\/([\d.]+)/);if(c.webkit=!!d)c.version=d[1];e&&(b.android=!0,b.version=e[2]),g&&(b.ios=b.iphone=!0,b.version=g[2].replace(/_/g,".")),f&&(b.ios=b.ipad=!0,b.version=f[2].replace(/_/g,".")),h&&(b.webos=!0,b.version=h[2]),i&&(b.touchpad=!0),l&&(b.blackberry=!0,b.version=l[2]),m&&(b.bb10=!0,b.version=m[2]),n&&(b.rimtabletos=!0,b.version=n[2]),o&&(c.playbook=!0),j&&(b.kindle=!0,b.version=j[1]),k&&(c.silk=!0,c.version=k[1]),!k&&b.android&&a.match(/Kindle Fire/)&&(c.silk=!0),p&&(c.chrome=!0,c.version=p[1]),q&&(c.firefox=!0,c.version=q[1]),b.tablet=!!(f||o||e&&!a.match(/Mobile/)||q&&a.match(/Tablet/)),b.phone=!b.tablet&&!!(e||g||h||l||m||p&&a.match(/Android/)||p&&a.match(/CriOS\/([\d.]+)/)||q&&a.match(/Mobile/))}b.call(a,navigator.userAgent),a.__detect=b}(Zepto),function(a){function g(a){return a._zid||(a._zid=d++)}function h(a,b,d,e){b=i(b);if(b.ns)var f=j(b.ns);return(c[g(a)]||[]).filter(function(a){return a&&(!b.e||a.e==b.e)&&(!b.ns||f.test(a.ns))&&(!d||g(a.fn)===g(d))&&(!e||a.sel==e)})}function i(a){var b=(""+a).split(".");return{e:b[0],ns:b.slice(1).sort().join(" ")}}function j(a){return new RegExp("(?:^| )"+a.replace(" "," .* ?")+"(?: |$)")}function k(b,c,d){a.type(b)!="string"?a.each(b,d):b.split(/\s/).forEach(function(a){d(a,c)})}function l(a,b){return a.del&&(a.e=="focus"||a.e=="blur")||!!b}function m(a){return f[a]||a}function n(b,d,e,h,j,n){var o=g(b),p=c[o]||(c[o]=[]);k(d,e,function(c,d){var e=i(c);e.fn=d,e.sel=h,e.e in f&&(d=function(b){var c=b.relatedTarget;if(!c||c!==this&&!a.contains(this,c))return e.fn.apply(this,arguments)}),e.del=j&&j(d,c);var g=e.del||d;e.proxy=function(a){var c=g.apply(b,[a].concat(a.data));return c===!1&&(a.preventDefault(),a.stopPropagation()),c},e.i=p.length,p.push(e),b.addEventListener(m(e.e),e.proxy,l(e,n))})}function o(a,b,d,e,f){var i=g(a);k(b||"",d,function(b,d){h(a,b,d,e).forEach(function(b){delete c[i][b.i],a.removeEventListener(m(b.e),b.proxy,l(b,f))})})}function t(b){var c,d={originalEvent:b};for(c in b)!r.test(c)&&b[c]!==undefined&&(d[c]=b[c]);return a.each(s,function(a,c){d[a]=function(){return this[c]=p,b[a].apply(b,arguments)},d[c]=q}),d}function u(a){if(!("defaultPrevented"in a)){a.defaultPrevented=!1;var b=a.preventDefault;a.preventDefault=function(){this.defaultPrevented=!0,b.call(this)}}}var b=a.zepto.qsa,c={},d=1,e={},f={mouseenter:"mouseover",mouseleave:"mouseout"};e.click=e.mousedown=e.mouseup=e.mousemove="MouseEvents",a.event={add:n,remove:o},a.proxy=function(b,c){if(a.isFunction(b)){var d=function(){return b.apply(c,arguments)};return d._zid=g(b),d}if(typeof c=="string")return a.proxy(b[c],b);throw new TypeError("expected function")},a.fn.bind=function(a,b){return this.each(function(){n(this,a,b)})},a.fn.unbind=function(a,b){return this.each(function(){o(this,a,b)})},a.fn.one=function(a,b){return this.each(function(c,d){n(this,a,b,null,function(a,b){return function(){var c=a.apply(d,arguments);return o(d,b,a),c}})})};var p=function(){return!0},q=function(){return!1},r=/^([A-Z]|layer[XY]$)/,s={preventDefault:"isDefaultPrevented",stopImmediatePropagation:"isImmediatePropagationStopped",stopPropagation:"isPropagationStopped"};a.fn.delegate=function(b,c,d){return this.each(function(e,f){n(f,c,d,b,function(c){return function(d){var e,g=a(d.target).closest(b,f).get(0);if(g)return e=a.extend(t(d),{currentTarget:g,liveFired:f}),c.apply(g,[e].concat([].slice.call(arguments,1)))}})})},a.fn.undelegate=function(a,b,c){return this.each(function(){o(this,b,c,a)})},a.fn.live=function(b,c){return a(document.body).delegate(this.selector,b,c),this},a.fn.die=function(b,c){return a(document.body).undelegate(this.selector,b,c),this},a.fn.on=function(b,c,d){return!c||a.isFunction(c)?this.bind(b,c||d):this.delegate(c,b,d)},a.fn.off=function(b,c,d){return!c||a.isFunction(c)?this.unbind(b,c||d):this.undelegate(c,b,d)},a.fn.trigger=function(b,c){if(typeof b=="string"||a.isPlainObject(b))b=a.Event(b);return u(b),b.data=c,this.each(function(){"dispatchEvent"in this&&this.dispatchEvent(b)})},a.fn.triggerHandler=function(b,c){var d,e;return this.each(function(f,g){d=t(typeof b=="string"?a.Event(b):b),d.data=c,d.target=g,a.each(h(g,b.type||b),function(a,b){e=b.proxy(d);if(d.isImmediatePropagationStopped())return!1})}),e},"focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select keydown keypress keyup error".split(" ").forEach(function(b){a.fn[b]=function(a){return a?this.bind(b,a):this.trigger(b)}}),["focus","blur"].forEach(function(b){a.fn[b]=function(a){return a?this.bind(b,a):this.each(function(){try{this[b]()}catch(a){}}),this}}),a.Event=function(a,b){typeof a!="string"&&(b=a,a=b.type);var c=document.createEvent(e[a]||"Events"),d=!0;if(b)for(var f in b)f=="bubbles"?d=!!b[f]:c[f]=b[f];return c.initEvent(a,d,!0,null,null,null,null,null,null,null,null,null,null,null,null),c.isDefaultPrevented=function(){return this.defaultPrevented},c}}(Zepto),function($){function triggerAndReturn(a,b,c){var d=$.Event(b);return $(a).trigger(d,c),!d.defaultPrevented}function triggerGlobal(a,b,c,d){if(a.global)return triggerAndReturn(b||document,c,d)}function ajaxStart(a){a.global&&$.active++===0&&triggerGlobal(a,null,"ajaxStart")}function ajaxStop(a){a.global&&!--$.active&&triggerGlobal(a,null,"ajaxStop")}function ajaxBeforeSend(a,b){var c=b.context;if(b.beforeSend.call(c,a,b)===!1||triggerGlobal(b,c,"ajaxBeforeSend",[a,b])===!1)return!1;triggerGlobal(b,c,"ajaxSend",[a,b])}function ajaxSuccess(a,b,c){var d=c.context,e="success";c.success.call(d,a,e,b),triggerGlobal(c,d,"ajaxSuccess",[b,c,a]),ajaxComplete(e,b,c)}function ajaxError(a,b,c,d){var e=d.context;d.error.call(e,c,b,a),triggerGlobal(d,e,"ajaxError",[c,d,a]),ajaxComplete(b,c,d)}function ajaxComplete(a,b,c){var d=c.context;c.complete.call(d,b,a),triggerGlobal(c,d,"ajaxComplete",[b,c]),ajaxStop(c)}function empty(){}function mimeToDataType(a){return a&&(a=a.split(";",2)[0]),a&&(a==htmlType?"html":a==jsonType?"json":scriptTypeRE.test(a)?"script":xmlTypeRE.test(a)&&"xml")||"text"}function appendQuery(a,b){return(a+"&"+b).replace(/[&?]{1,2}/,"?")}function serializeData(a){a.processData&&a.data&&$.type(a.data)!="string"&&(a.data=$.param(a.data,a.traditional)),a.data&&(!a.type||a.type.toUpperCase()=="GET")&&(a.url=appendQuery(a.url,a.data))}function parseArguments(a,b,c,d){var e=!$.isFunction(b);return{url:a,data:e?b:undefined,success:e?$.isFunction(c)?c:undefined:b,dataType:e?d||c:c}}function serialize(a,b,c,d){var e,f=$.isArray(b);$.each(b,function(b,g){e=$.type(g),d&&(b=c?d:d+"["+(f?"":b)+"]"),!d&&f?a.add(g.name,g.value):e=="array"||!c&&e=="object"?serialize(a,g,c,b):a.add(b,g)})}var jsonpID=0,document=window.document,key,name,rscript=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,scriptTypeRE=/^(?:text|application)\/javascript/i,xmlTypeRE=/^(?:text|application)\/xml/i,jsonType="application/json",htmlType="text/html",blankRE=/^\s*$/;$.active=0,$.ajaxJSONP=function(a){if("type"in a){var b="jsonp"+ ++jsonpID,c=document.createElement("script"),d=function(){clearTimeout(g),$(c).remove(),delete window[b]},e=function(c){d();if(!c||c=="timeout")window[b]=empty;ajaxError(null,c||"abort",f,a)},f={abort:e},g;return ajaxBeforeSend(f,a)===!1?(e("abort"),!1):(window[b]=function(b){d(),ajaxSuccess(b,f,a)},c.onerror=function(){e("error")},c.src=a.url.replace(/=\?/,"="+b),$("head").append(c),a.timeout>0&&(g=setTimeout(function(){e("timeout")},a.timeout)),f)}return $.ajax(a)},$.ajaxSettings={type:"GET",beforeSend:empty,success:empty,error:empty,complete:empty,context:null,global:!0,xhr:function(){return new window.XMLHttpRequest},accepts:{script:"text/javascript, application/javascript",json:jsonType,xml:"application/xml, text/xml",html:htmlType,text:"text/plain"},crossDomain:!1,timeout:0,processData:!0,cache:!0},$.ajax=function(options){var settings=$.extend({},options||{});for(key in $.ajaxSettings)settings[key]===undefined&&(settings[key]=$.ajaxSettings[key]);ajaxStart(settings),settings.crossDomain||(settings.crossDomain=/^([\w-]+:)?\/\/([^\/]+)/.test(settings.url)&&RegExp.$2!=window.location.host),settings.url||(settings.url=window.location.toString()),serializeData(settings),settings.cache===!1&&(settings.url=appendQuery(settings.url,"_="+Date.now()));var dataType=settings.dataType,hasPlaceholder=/=\?/.test(settings.url);if(dataType=="jsonp"||hasPlaceholder)return hasPlaceholder||(settings.url=appendQuery(settings.url,"callback=?")),$.ajaxJSONP(settings);var mime=settings.accepts[dataType],baseHeaders={},protocol=/^([\w-]+:)\/\//.test(settings.url)?RegExp.$1:window.location.protocol,xhr=settings.xhr(),abortTimeout;settings.crossDomain||(baseHeaders["X-Requested-With"]="XMLHttpRequest"),mime&&(baseHeaders.Accept=mime,mime.indexOf(",")>-1&&(mime=mime.split(",",2)[0]),xhr.overrideMimeType&&xhr.overrideMimeType(mime));if(settings.contentType||settings.contentType!==!1&&settings.data&&settings.type.toUpperCase()!="GET")baseHeaders["Content-Type"]=settings.contentType||"application/x-www-form-urlencoded";settings.headers=$.extend(baseHeaders,settings.headers||{}),xhr.onreadystatechange=function(){if(xhr.readyState==4){xhr.onreadystatechange=empty,clearTimeout(abortTimeout);var result,error=!1;if(xhr.status>=200&&xhr.status<300||xhr.status==304||xhr.status==0&&protocol=="file:"){dataType=dataType||mimeToDataType(xhr.getResponseHeader("content-type")),result=xhr.responseText;try{dataType=="script"?(1,eval)(result):dataType=="xml"?result=xhr.responseXML:dataType=="json"&&(result=blankRE.test(result)?null:$.parseJSON(result))}catch(e){error=e}error?ajaxError(error,"parsererror",xhr,settings):ajaxSuccess(result,xhr,settings)}else ajaxError(null,xhr.status?"error":"abort",xhr,settings)}};var async="async"in settings?settings.async:!0;xhr.open(settings.type,settings.url,async);for(name in settings.headers)xhr.setRequestHeader(name,settings.headers[name]);return ajaxBeforeSend(xhr,settings)===!1?(xhr.abort(),!1):(settings.timeout>0&&(abortTimeout=setTimeout(function(){xhr.onreadystatechange=empty,xhr.abort(),ajaxError(null,"timeout",xhr,settings)},settings.timeout)),xhr.send(settings.data?settings.data:null),xhr)},$.get=function(a,b,c,d){return $.ajax(parseArguments.apply(null,arguments))},$.post=function(a,b,c,d){var e=parseArguments.apply(null,arguments);return e.type="POST",$.ajax(e)},$.getJSON=function(a,b,c){var d=parseArguments.apply(null,arguments);return d.dataType="json",$.ajax(d)},$.fn.load=function(a,b,c){if(!this.length)return this;var d=this,e=a.split(/\s/),f,g=parseArguments(a,b,c),h=g.success;return e.length>1&&(g.url=e[0],f=e[1]),g.success=function(a){d.html(f?$("<div>").html(a.replace(rscript,"")).find(f):a),h&&h.apply(d,arguments)},$.ajax(g),this};var escape=encodeURIComponent;$.param=function(a,b){var c=[];return c.add=function(a,b){this.push(escape(a)+"="+escape(b))},serialize(c,a,b),c.join("&").replace(/%20/g,"+")}}(Zepto),function(a){a.fn.serializeArray=function(){var b=[],c;return a(Array.prototype.slice.call(this.get(0).elements)).each(function(){c=a(this);var d=c.attr("type");this.nodeName.toLowerCase()!="fieldset"&&!this.disabled&&d!="submit"&&d!="reset"&&d!="button"&&(d!="radio"&&d!="checkbox"||this.checked)&&b.push({name:c.attr("name"),value:c.val()})}),b},a.fn.serialize=function(){var a=[];return this.serializeArray().forEach(function(b){a.push(encodeURIComponent(b.name)+"="+encodeURIComponent(b.value))}),a.join("&")},a.fn.submit=function(b){if(b)this.bind("submit",b);else if(this.length){var c=a.Event("submit");this.eq(0).trigger(c),c.defaultPrevented||this.get(0).submit()}return this}}(Zepto),function(a,b){function s(a){return t(a.replace(/([a-z])([A-Z])/,"$1-$2"))}function t(a){return a.toLowerCase()}function u(a){return d?d+a:t(a)}var c="",d,e,f,g={Webkit:"webkit",Moz:"",O:"o",ms:"MS"},h=window.document,i=h.createElement("div"),j=/^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,k,l,m,n,o,p,q,r={};a.each(g,function(a,e){if(i.style[a+"TransitionProperty"]!==b)return c="-"+t(a)+"-",d=e,!1}),k=c+"transform",r[l=c+"transition-property"]=r[m=c+"transition-duration"]=r[n=c+"transition-timing-function"]=r[o=c+"animation-name"]=r[p=c+"animation-duration"]=r[q=c+"animation-timing-function"]="",a.fx={off:d===b&&i.style.transitionProperty===b,speeds:{_default:400,fast:200,slow:600},cssPrefix:c,transitionEnd:u("TransitionEnd"),animationEnd:u("AnimationEnd")},a.fn.animate=function(b,c,d,e){return a.isPlainObject(c)&&(d=c.easing,e=c.complete,c=c.duration),c&&(c=(typeof c=="number"?c:a.fx.speeds[c]||a.fx.speeds._default)/1e3),this.anim(b,c,d,e)},a.fn.anim=function(c,d,e,f){var g,h={},i,t="",u=this,v,w=a.fx.transitionEnd;d===b&&(d=.4),a.fx.off&&(d=0);if(typeof c=="string")h[o]=c,h[p]=d+"s",h[q]=e||"linear",w=a.fx.animationEnd;else{i=[];for(g in c)j.test(g)?t+=g+"("+c[g]+") ":(h[g]=c[g],i.push(s(g)));t&&(h[k]=t,i.push(k)),d>0&&typeof c=="object"&&(h[l]=i.join(", "),h[m]=d+"s",h[n]=e||"linear")}return v=function(b){if(typeof b!="undefined"){if(b.target!==b.currentTarget)return;a(b.target).unbind(w,v)}a(this).css(r),f&&f.call(this)},d>0&&this.bind(w,v),this.size()&&this.get(0).clientLeft,this.css(h),d<=0&&setTimeout(function(){u.each(function(){v.call(this)})},0),this},i=null}(Zepto)
  </script>
  <script>
  /**#Interface
  A singleton object holding all widget constructors and a couple of other methods / properties. It is automatically created as soon as interface.js is loaded.
  **/

  /**###Interface.extend : method  
  This method deep copies all the properties and methods of one object to another.  

  param **destination** Object. The object that properties and methods will be inserted into.  
  param **source** Object. The object providing the properties and methods for copying.  
  **/

  /**###Interface.mouseDown : property  
  Boolean. This property tells whether the left mouse button (in non-touch browsers) is currently pressed.
  **/

  /**###Interface.useTouch : property  
  Boolean. Whether or not a touch UI browser is being used.
  **/

  /**###Interface.isAndroid : property  
  Boolean. Whether or not the browser is running under Android. This is used to determine the range of accelerometer values generated.
  **/
  var Interface = {
    extend : function(destination, source) {
      for (var property in source) {
    		var keys = property.split(".");
      
    		if(source[property] instanceof Array && source[property].length < 100) { // don't copy large array buffers
    	    destination[property] = source[property].slice(0);
        } else {
          destination[property] = source[property];
        }
      }
      return destination;
    },
  
    isAndroid : (function() {
      var ua = navigator.userAgent.toLowerCase();
      return ua.indexOf("android") > -1;
    })(),
  
    panels : [],
    mouseDown : false,
    useTouch : 'ontouchstart' in document.documentElement,
  };

  Interface.Presets = {
    dictionary : typeof localStorage.interfacejs === 'undefined' ? {} : JSON.parse( localStorage.interfacejs ),
  
    save : function(name) {
      var preset = [];
      for(var h = 0; h < Interface.panels.length; h++) {
        var panel = Interface.panels[h];
        preset[h] = [];
        for(var i = 0; i < panel.children.length; i++) {
          var widget = panel.children[i];
          if(typeof widget.children === 'object') {
            var children = [];
            for(var j = 0; j < widget.children.length; j++) {
              children[j] = widget.children[j].value;
            }
            preset[h][i] = children;
          }else{
            preset[h][i] = widget.value;
          }
        }
        this.dictionary[ name ] = preset;
        localStorage.interfacejs = JSON.stringify( this.dictionary );
      }
    },
  
    load : function(name) {
      var preset = this.dictionary[ name ];
      for(var h = 0; h < Interface.panels.length; h++) {
        var panel = Interface.panels[h]; 
        for(var i = 0; i < panel.children.length; i++) {
          var widget = panel.children[i];
          if(typeof widget.children === 'object') {
            for(var j = 0; j < widget.children.length; j++) {
               widget.children[j].setValue( preset[h][i][j] );
            }
          }else{
            widget.setValue( preset[h][i] );
          }
        }
      }
    },
  
    list : function() {
      return Object.keys( this.dictionary );
    },
  };
  /**#Interface.Panel - Widget
  A panel is a container for on-screen widgets. There can be multiple panels in a HTML page. Panels are the starting point for event processing in Interface.js.
  **/

  /**###Interface.Panel.children : property  
  Array. An array of all widgets displayed in the panel
  **/

  /**###Interface.Panel.shouldDraw : property  
  Boolean. Whenever the panel refreshes itself it will redraw widgets found in this array.
  **/

  /**###Interface.Panel.fps : property  
  Number. The number of times the panel should refresh itself per second.
  **/

  /**###Interface.Panel.useRelativeSizesAndPositions : property  
  Boolean. This determines whether widgets in the panel uses sizes/positions relative to the size of the panel or use absolute pixel coordinates.
  **/

  /**###Interface.Panel.container : property  
  HTMLElement. The HTMLElement (such as a div tag) containing the Panel.
  **/

  /**###Interface.Panel.canvas : property  
  HTMLElement. The canvas element that the Panel draws onto. This element is created when the panel is initialized.
  **/

  /**###Interface.Panel.touchEvent : method  
  The starting point for on-screen all touch event handling in a Panel. This method distributes events to all child widgets.  
  
  param **event** HTML Touch Event Object.
  **/

  /**###Interface.Panel.mouseEvent : method  
  The starting point for on-screen all mouse event handling in a Panel. This method distributes events to all child widgets.  
  
  param **event** HTML Mouse Event Object.
  **/

  /**###Interface.Panel.init : method  
  Initialization method called automatically when panel is instantiated.
  **/

  /**###Interface.Panel.x : property  
  Number. The x position of the panel in absolute coordinates relative to the window.
  **/
  /**###Interface.Panel.y : property  
  Number. The y position of the panel in absolute coordinates relative to the window.
  **/
  /**###Interface.Panel.width : property  
  Number. The width of the panel in pixels
  **/
  /**###Interface.Panel.width : property  
  Number. The height of the panel in pixels
  **/

  /**###Interface.Panel.draw : method  
  This method tells all 'dirty' widgets stored in the shouldDraw property to draw themselves.
  **/
  /**###Interface.Panel.refresh : method  
  Clear the entire panel and then tell all widgets to draw themselves.
  **/

  /**###Interface.Panel.add : method  
  Add a new widget to the panel  
  
  param **widget** Object. The widget to be added. Motion widgets do not need to be added to the Panel
  **/

  /**###Interface.Panel.setBackgroundColor : method  
  Set the background color the panel using a css color value.  
  
  param **cssColor** String. Any valid css color, such as 'red', '#f00', or 'rgb(255,0,0)'.
  **/

  /**###Interface.Panel.background : property  
  String. The default background color for all widgets in the panel. THIS IS NOT THE BACKGROUND COLOR FOR THE PANEL. Any valid css color, such as 'red', '#f00', or 'rgb(255,0,0)' can be assigned to this property.
  **/
  /**###Interface.Panel.fill : property  
  String. The default fill color for all widgets in the panel. Any valid css color, such as 'red', '#f00', or 'rgb(255,0,0)' can be assigned to this property.
  **/
  /**###Interface.Panel.stroke : property  
  String. The default stroke color for all widgets in the panel. Any valid css color, such as 'red', '#f00', or 'rgb(255,0,0)' can be assigned to this property.
  **/
  Interface.Panel = function() {
    var self = this,
        _container = arguments.length >= 1 ? arguments[0].container : undefined;

    Interface.extend(this, {
      type: 'Panel',
      active: true,
      children:     [],
      shouldDraw :  [],
      fps : 30,
      useRelativeSizesAndPositions : true,
      labelSize: '12px',
      font:'normal 12px Helvetica',
      serializeMe: ['fps', 'useRelativeSizesAndPositions', 'labelSize', 'font', 'background', 'fill', 'stroke', 'backgroundColor'],
    
      container: (function() {
        if(typeof _container === 'undefined') {
          $('body').css({
            margin : 0,
            padding: 0,
          });
        
          var d = $('<div id="container">');
          d.css({
            width:$(window).width(),
            height:$(window).height(),
            display:'block',
            margin:0,
            padding:0,
            position:'absolute',
            left:0,
            top:0
          });
        
          $('body').append(d);
        
          return d;
        }else{
          return _container;
        }
      })(),
    
      canvas:  document.createElement('canvas'),
    
      touchEvent : function(event) {
        if(self.active) {
          for (var j = 0; j < event.changedTouches.length; j++){
            var touch = event.changedTouches.item(j);		
        
            for(var i = 0; i < self.children.length; i++) {
              touch.x = touch.pageX - self.x;
              touch.y = touch.pageY - self.y;
              touch.type = event.type;
              self.children[i].touchEvent(touch);
            }
        		//var breakCheck = this.events[event.type].call(this, touch);
		
            //if(breakCheck) break;
        	}
          event.preventDefault(); // HTML Elements must simulate touch events in their touchEvent method
        }
      },
    
      mouseEvent : function(e) {
        if(self.active) {
          if(e.type === 'mousedown') {
            Interface.mouseDown = true;
          }else if(e.type === 'mouseup') {
            Interface.mouseDown = false;
          }
      
          var event = {
            x : e.offsetX,// - self.x,
            y : e.offsetY,// - self.y,
            type: e.type,
          }
          //console.log("MOUSE", event, self.y, e.pageY, e.layerY, e.clientY, e );
      
          for(var i = 0; i < self.children.length; i++) {
            self.children[i].mouseEvent(event);
          }
        }
      },
    
      init : function() {
        var offset = $(this.container).offset();
        this.width  = $(this.container).width();
        this.height = $(this.container).height();
        this.x      = offset.left;
        this.y      = offset.top;
      
        if( isNaN(this.x) ) this.x = 0;
        if( isNaN(this.y) ) this.y = 0;      
      
        $(this.canvas).attr({
          'width':  this.width,
          'height': this.height,
        });

        $(this.container).css({ 'user-select': 'none', '-webkit-user-select': 'none'});
      
        $(this.container).append(this.canvas);
      
        this.ctx = this.canvas.getContext( '2d' );
        this.ctx.translate(0.5, 0.5);
        this.ctx.lineWidth = 1;
      
        if(Interface.useTouch) {
          $(this.container).on( 'touchstart', this.touchEvent );
          $(this.container).on( 'touchmove',  this.touchEvent );
          $(this.container).on( 'touchend',   this.touchEvent );
        }else{
          $(this.container).on( 'mousedown', this.mouseEvent );
          $(this.container).on( 'mousemove', this.mouseEvent );
          $(this.container).on( 'mouseup',   this.mouseEvent );                
        }
      },
    
      draw : function() {
        if(this.active) {
          for(var i = 0; i < this.shouldDraw.length; i++) {
            this.shouldDraw[i].draw();
          }
          this.shouldDraw.length = 0;
        }
      },
    
      getWidgetWithName: function( name ) {
        for(var i = 0; i < this.children.length; i++) {
          if( this.children[i].name === name) {
            return this.children[i];
          }
        }
      },
    
      redoBoundaries : function() {
        var offset = $(this.container).offset();
        this.width  = $(this.container).width();
        this.height = $(this.container).height();
        this.x      = offset.left;
        this.y      = offset.top;
      
        if( isNaN(this.x) ) this.x = 0;
        if( isNaN(this.y) ) this.y = 0;      
      
        $(this.canvas).attr({
          'width':  this.width,
          'height': this.height,
        });
      
        this.ctx.translate(0.5, 0.5);
        this.ctx.lineWidth = 1;
      
        this.refresh();
      },
    
      refresh: function() {
        if(this.active) {
          this.ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
          for(var i = 0; i < this.children.length; i++) {
            this.children[i].draw();
          }
        }
      },
    
      add: function() {
        for(var i = 0; i < arguments.length; i++) {
          var widget = arguments[i];
        
          widget.panel =      this;
          widget.canvas =     this.canvas;
          widget.container =  this.container;
          widget.ctx =        this.ctx;
        
          this.children.push( widget );
          if(widget._init && !widget.added) widget._init();
        
          widget.draw();
          widget.added = true;
        
          if(typeof widget.add === 'function') widget.add();
        }
      },
    
      clear : function() {
        this.ctx.clearRect( 0,0,this.width,this.height );
        this.children.length = 0;
      },
      remove: function(widget) {
        this.ctx.clearRect( widget._x(), widget._y(), widget._width(), widget._height() );
      
        if(typeof widget.children !== 'undefined' && widget.type !== "XY") {
          for(var i = 0; i < widget.children.length; i++) {
            this.children.splice( this.children.indexOf(widget.children[i]) );
          }
        }else{
          console.log(this.children, this.children.indexOf( widget ) );
          if(this.children.indexOf( widget ) > -1) {
            this.children.splice( this.children.indexOf( widget ) );
            if(typeof widget.remove === 'function') widget.remove();
          }
          console.log("DELETED", this.children.indexOf( widget ) )
        }
      
      },
    
      /*setBackgroundColor : function(color) {
        this.backgroundColor = color;
        $(this.container).css({ backgroundColor:color });
      },*/
    });
  
    if(typeof arguments[0] !== 'undefined') Interface.extend(this, arguments[0]);
    if(this.backgroundColor) this.setBackgroundColor( this.backgroundColor );
  
    this.init();

    this.timer = setInterval( function() { self.draw(); }, Math.round(1000 / this.fps) );

    var childBackground ='#000',
        childFill = '#333',
        childStroke = '#999',
        background = 'transparent',
        self = this,
        useRelativeSizesAndPositions = this.useRelativeSizesAndPositions;
      
    Object.defineProperties(this, {
      'useRelativeSizesAndPositions' : {
        get: function() { return useRelativeSizesAndPositions; },
        set: function(val) {
          if(val !== useRelativeSizesAndPositions) {
            useRelativeSizesAndPositions = val;
            if(val === false) {
              for(var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                child.bounds = [
                  Math.round( child.x * this.width ),
                  Math.round( child.y * this.height ),
                  Math.round( child.width * this.width ),
                  Math.round( child.height * this.height ),
                ];
              }
            }else{
              for(var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                child.bounds = [
                  child.x / this.width,
                  child.y / this.height,
                  child.width / this.width,
                  child.height / this.height,
                ];
              }
            }
          } 
          this.refresh();
        },
      },
      'background': {
        get: function() { return background; },
        set: function(val) { 
          background = val;
          $(this.container).css({ backgroundColor:background });
        },
      },
      'childBackground': {
        get: function() { return childBackground; },
        set: function(val) { 
          childBackground = val;
          self.refresh();
        },
      },
      'childStroke': {
        get: function() { return childStroke; },
        set: function(val) { 
          childStroke = val;
          self.refresh();
        },
      },
      'childFill': {
        get: function() { return childFill; },
        set: function(val) { 
          childFill = val;
          self.refresh();
        },
      }
    });
    if(arguments[0]) {
      if(arguments[0].childBackground) this.childBackground = arguments[0].childBackground;
      if(arguments[0].childFill) this.childFill = arguments[0].childFill;
      if(arguments[0].childStroke) this.childStroke = arguments[0].childStroke;    
    }
    Interface.panels.push( this );
  };

  var convertMouseEvent = function(eventName) {
    switch(eventName) {
      case 'mousedown':
        return 'touchmousedown';
      case 'mousemove':
        return 'touchmousemove';
      case 'mouseup':
        return 'touchmouseup';
      default:
        return eventName;
    }
  };

  var convertTouchEvent = function(eventName) {
    switch(eventName) {
      case 'touchstart':
        return 'touchmousedown';
      case 'touchmove':
        return 'touchmousemove';
      case 'touchend':
        return 'touchmouseup';
      default:
        return eventName;
    }
  };

  /**#Interface.Widget - Widget
  The prototype object for all Interface.js widgets. These methods and properties are inherited by all widgets.
  **/

  /**###Interface.Widget.x : property  
  Number. The horizontal position of the widget inside of its parent panel. By default, this position is determined relative to the size of the widget's containing panel, but absolute values can also be used if the panel's useRelativeSizesAndPositions property is set to false.
  **/
  /**###Interface.Widget.y : property  
  Number. The vertical position of the widget inside of its parent panel. By default, this position is determined relative to the size of the widget's containing panel, but absolute values can also be used if the panel's useRelativeSizesAndPositions property is set to false.
  **/
  /**###Interface.Widget.width : property  
  Number. The width of the widget. By default, this is determined relative to the size of the widget's containing panel, but absolute values can also be used if the panel's useRelativeSizesAndPositions property is set to false.
  **/
  /**###Interface.Widget.height : property  
  Number. The width of the widget. By default, this is determined relative to the size of the widget's containing panel, but absolute values can also be used if the panel's useRelativeSizesAndPositions property is set to false.
  **/
  /**###Interface.Widget.bounds : property  
  Array. A shorthand to set x,y,width and height simultaneously upon initialization. By default, these values are determined relative to the size of the widget's containing panel, but absolute values can also be used if the panel's useRelativeSizesAndPositions property is set to false.
  **/
  /**###Interface.Widget.min : property  
  Number. Default 0. The minimum value the widget should output.
  **/
  /**###Interface.Widget.max : property  
  Number. Default 1. The maximum value the widget should output.
  **/
  /**###Interface.Widget.ontouchstart : method  
  Function. A user defined event handler for whenever a touch begins over a widget.
  **/
  /**###Interface.Widget.ontouchmove : method  
  Function. A user defined event handler for whenever a touch moves over a widget.
  **/
  /**###Interface.Widget.ontouchend : method  
  Function. A user defined event handler for whenever a touch ends.
  **/
  /**###Interface.Widget.onmousedown : method  
  Function. A user defined event handler for whenever a mouse press occurs over a widget.
  **/
  /**###Interface.Widget.onmousemove : method  
  Function. A user defined event handler for whenever a mouse moves over a widget while its button is pressed.
  **/
  /**###Interface.Widget.onmouseup : method  
  Function. A user defined event handler for whenever a mouse press ends.
  **/
  /**###Interface.Widget.ontouchmousedown : method  
  Function. A user defined event handler for whenever a mouse press or touch occurs over a widget.
  **/
  /**###Interface.Widget.ontouchmousemove : method  
  Function. A user defined event handler for whenever a mouse or touch moves over a widget.
  **/
  /**###Interface.Widget.ontouchmouseup : method  
  Function. A user defined event handler for whenever a mouse press ends or a touch leaves the screen.
  **/

  /**###Interface.Widget.init : method  
  This method is called as soon as widgets are created. It copies properties passed in the constructor to the widget and also copies some default property values.  
  
  param **options** Object. A dictionary of options for the widget to be initilized with.
  **/
  /**###Interface.Widget.refresh : method  
  Tell the widget to redraw itself. This method adds the widget to the shouldDraw array of the parent panel.
  **/
  /**###Interface.Widget.setValue : method  
  Programmatically change the value of the widget. You can optionally not have the widget redraw itself when calling this method.  
  
  param **value** Number or String. The new value for the widget.  
  param **doNotDraw** Optional, default false. Whether or not the widget should redraw itself.
  **/
  /**###Interface.Widget.hitTest : method  
  Given an HTML touch or mouse event, determine if the event overlaps a graphical widget.  
  
  param **event** HTMLEvent. The touch or mouse event to check
  **/
  /**###Interface.Widget.hitTest : method  
  Given an HTML touch or mouse event, determine if the event overlaps a graphical widget.  
  
  param **event** HTMLEvent. The touch or mouse event to check
  **/
  /**###Interface.Widget.draw : method  
  Tell the widget to draw itself. This method must be overridden by every graphical widget.
  **/
  /**###Interface.Widget.mouseEvent : method  
  The default mouse event handler for the widget. This method also calls any user defined mouse event handlers. This method should probably never be called manually, but you might want to override it.
  
  param **event** HTMLEvent. The mouse event to process
  **/
  /**###Interface.Widget.mouseEvent : method  
  The default touch event handler for the widget. This method also calls any user defined touch event handlers. This method should probably never be called manually, but you might want to override it.
  
  param **event** HTMLEvent. The touch event to process
  **/
  /**###Interface.Widget.sendTargetMessage : method  
  If the widget has a target and key property, set the key property or call the key method on the target using the widgets current value.
  **/
  /**###Interface.Widget._background : method  
  returns Color. If the widget has a background color specified, return that, otherwise return the background color of the widget's parent panel.
  **/
  /**###Interface.Widget._stroke : method  
  returns Color. If the widget has a stroke color specified, return that, otherwise return the stroke color of the widget's parent panel.
  **/
  /**###Interface.Widget._fill : method  
  returns Color. If the widget has a fill color specified, return that, otherwise return the fill color of the widget's parent panel.
  **/

  /**###Interface.Widget._x : method  
  returns Number. Return the widget's x position as a pixel value relative to the position of the panel. Note that this method will always return the pixel value, even if the panel uses relative values to determine sizes and positions.
  **/
  /**###Interface.Widget._y : method  
  returns Number. Return the widget's y position as a pixel value relative to the position of the panel. Note that this method will always return the pixel value, even if the panel uses relative values to determine sizes and positions.
  **/
  /**###Interface.Widget._width : method  
  returns Number. Return the widget's width. Note that this method will always return a size in pixels, even if the panel uses relative values to determine sizes and positions.
  **/
  /**###Interface.Widget._height : method  
  returns Number. Return the widget's height. Note that this method will always return a size in pixels, even if the panel uses relative values to determine sizes and positions.
  **/
  var __widgetCount = 0;
  var widgetDefaults = {
    hasFocus      : false,
    requiresFocus : true,
    min           : 0,
    max           : 1,
    value         : 0,
    lastValue     : null,
    name          : null,
    events : {
      ontouchstart  : null,
      ontouchmove   : null,
      ontouchend    : null,
      onmousedown   : null,
      onmousemove   : null,
      onmouseup     : null,
      ontouchmousedown : null,
      ontouchmousemove : null,    
      ontouchmouseup : null,    
      onvaluechange : null,
    },
  }
  Interface.Widget = {
    init : function( options ) {
      this.added = false;
      Interface.extend( this, widgetDefaults);
    
      this.name = options.name || this.type + "_" + __widgetCount++;
      this.target = "OSC";
      this.key = "/" + this.name;   
    
      Interface.extend( this, options);
        
      if(this.bounds) {
        this.x = options.bounds[0];
        this.y = options.bounds[1];
        this.width  = options.bounds[2];
        this.height = options.bounds[3];
      }
      
      if(this.colors) {
        this.background = options.colors[0];
        this.fill       = options.colors[1];
        this.stroke     = options.colors[2];                
      }
    
      this.focusedTouches = [];
    
      if(this.value) this.setValue(this.value, true);
    
      var bounds = this.bounds || [this.x, this.y, this.width, this.height],
          x = this.x, y = this.y, width = this.width, height = this.height, value = this.value;
    
      Object.defineProperties(this, {
        bounds : {
          configurable: true,
          get : function() { return bounds; },
          set : function(_bounds) { bounds = _bounds; this.x = bounds[0]; this.y = bounds[1]; this.width = bounds[2]; this.height = bounds[3]; }
        },
        x : {
          configurable: true,        
          get : function() { return x; },
          set : function(val) { this.clear(); x = val; this.refresh(); },
        },
        y : {
          configurable: true,        
          get : function() { return y; },
          set : function(val) { this.clear(); y = val; this.refresh(); },
        },
        width : {
          configurable: true,        
          get : function() { return width; },
          set : function(val) { this.clear(); width = val; this.refresh(); },
        },
        height : {
          configurable: true,        
          get : function() { return height; },
          set : function(val) { this.clear(); height = val; this.refresh(); },
        },
        /*value : {
          configurable: true,        
          get : function() { return value; },
          set : function(val) { if(value !== val) { value = val; this.refresh(); } },
        },*/        
      });
    },
  
    clear : function() {
      this.panel.ctx.clearRect( this._x(), this._y(), this._width(), this._height() );
    },
  
    refresh : function() {
      if(this.panel.shouldDraw.indexOf(this) === -1) {
        this.panel.shouldDraw.push(this);
      }
    },
  
    setValue : function(value, doNotDraw) {
      var r = this.max - this.min,
          v = value;
        
      this.value = value;
                
      if(this.min !== 0 || this.max !== 1) {
        v -= this.min;
        this._value = v / r;
      }else{
        this._value = this.value;
      }
    
      if(!doNotDraw) this.refresh();
    },
  
    hitTest : function(e) {
      if(e.x >= this._x() && e.x <= this._x() + this._width()) {
      	if(e.y >= this._y() && e.y <= this._y() + this._height()) {  
      		return true;
      	} 
      }
    
      return false;
    },
  
    mouseEvent : function(e) { 
      var isHit = this.hitTest(e);
      var touchMouseName = convertMouseEvent(e.type);
    
      if(isHit || this.hasFocus || !this.requiresFocus) {
        if(e.type === 'mousedown') this.hasFocus = true;
      
        if(this[e.type]) this[e.type](e, isHit);  // normal event
      
        if(this['on'+e.type]) this['on'+e.type](e, isHit); // user defined event
        if(this['on'+touchMouseName]) this['on'+touchMouseName](e, isHit);  // user defined event
      }
      if(e.type === 'mouseup') this.hasFocus = false;
    },
  
    touchEvent : function(touch) {  // event type is stored in touch by Panel
      var isHit = this.hitTest(touch);
      var touchMouseName = convertTouchEvent(touch.type);
      if(isHit || this.hasFocus || !this.requiresFocus) {
        if(touch.type === 'touchstart') {
          this.focusedTouches.push(touch);
          this.hasFocus = true;
        }
        if(this[touch.type])
          this[touch.type](touch, isHit);  // normal event
      
        if(this['on'+touch.type]) this['on'+touch.type](touch, isHit);          // user defined event
        if(this['on'+touchMouseName]) this['on'+touchMouseName](touch, isHit);  // user defined event
      }
      if(touch.type === 'touchend') {
        for(var i = 0; i < this.focusedTouches.length; i++) {
          if(this.focusedTouches[i].id === touch.id) {
            this.focusedTouches.splice(i, 1);
            if(this.focusedTouches.length === 0) this.hasFocus = false;
            break;
          }
        }
      }
    },
  
    draw : function() {},
  
    sendTargetMessage : function() {
      if(this.target && this.key) {
        if(this.target === "OSC") {
          if(Interface.OSC) {
            if(typeof this.values === 'undefined') {
              var tt = typeof this.value === 'string' ? 's' : 'f';
              Interface.OSC.send(this.key, tt, [ this.value ] );
            }else{
              var tt = '';
              for(var i = 0; i < this.values.length; i++) {
                tt += typeof this.value === 'string' ? 's' : 'f';
              }
              Interface.OSC.send( this.key, tt, this.values );
            }
          }
        }else if(this.target === "MIDI") {
          if(Interface.MIDI) {
            Interface.MIDI.send( this.key[0],this.key[1],this.key[2], this.value )
          }
        }else{
          if(typeof this.target[this.key] === 'function') {
            this.target[this.key]( this.value );
          }else{
            this.target[this.key] = this.value;
          }
        }
      }  
    },
  
    _background : function() { return this.background || this.panel.childBackground; },
    _stroke : function() { return this.stroke || this.panel.childStroke; },
    _fill : function() { return this.fill || this.panel.childFill; },
  
    _x : function() { return this.panel.useRelativeSizesAndPositions ? Math.floor(this.x * this.panel.width)  : this.x; },
    _y : function() { return this.panel.useRelativeSizesAndPositions ? Math.floor(this.y * this.panel.height) : this.y; },
    _width  : function() { return this.panel.useRelativeSizesAndPositions ? Math.floor(this.width * this.panel.width)  : this.width; },
    _height : function() { return this.panel.useRelativeSizesAndPositions ? Math.floor(this.height * this.panel.height) : this.height; },
  
    _font : function() { 
      var font = this.font || this.panel.font;

      return font;
    },
    label:null,
  
    _serializeMe : [
      "background", "stroke", "fill", "x", "y", "width", "height", "value",
      "label", "onmousedown", "onmousemove", "onmouseup", "ontouchmousedown", "ontouchmousemove", "ontouchmouseup",
      "ontouchstart", "ontouchmove", "ontouchend", "onvaluechange", "name", "type", "target", "key"
    ],
  };

  /**#Interface.Slider - Widget
  A vertical or horizontal slider.

  ## Example Usage##
  `a = new Interface.Slider({ bounds:[0,0,1,.2], isVertical:false });  
  panel = new Interface.Panel();
  panel.add(a);
  `  
  ## Constructor   
  **param** *properties*: Object. A dictionary of property values (see below) to set for the slider on initialization.
  - - - -
  **/
  /**###Interface.Slider.isVertical : property
  Boolean. Whether or not the slider draws itself vertically or horizontally. Note this does not affect the boundaries of the slider, just the orientation of the slider's movement.
  **/

  Interface.Slider = function() {
    Interface.extend(this, {
      type : 'Slider',
      isVertical : true,
      serializeMe : ["isVertical"],
    
      draw : function() {
        var x = this._x(),
            y = this._y(),
            width = this._width(),
            height= this._height();
          
        this.ctx.fillStyle = this._background();
        this.ctx.fillRect( x, y, width, height );
      
        this.ctx.fillStyle = this._fill();
      
        if(this.isVertical) {
          this.ctx.fillRect( x, y + height - this._value * height, width, this._value * height);
        }else{
          this.ctx.fillRect( x, y, width * this._value, height);
        }
      
        if(this.label) {
          this.ctx.fillStyle = this._stroke();
          this.ctx.textBaseline = 'middle';
          this.ctx.textAlign = 'center';
          this.ctx.font = this._font();
          this.ctx.fillText(this.label, x + width / 2, y + height / 2);
        }
      
        this.ctx.strokeStyle = this._stroke();
        this.ctx.strokeRect( x, y, width, height );      
      },
    
      changeValue : function( xOffset, yOffset ) {
        if(this.hasFocus || !this.requiresFocus) {
        
          this._value = this.isVertical ? 1 - (yOffset / this._height()) : xOffset / this._width();
        
          if(this._value < 0) {
            this._value = 0;
            // this.hasFocus = false;
          }else if(this._value > 1) {
            this._value = 1;
            // this.hasFocus = false;
          }
        
          this.value = this.min + (this.max - this.min) * this._value;
        
          if(this.value !== this.lastValue) {
            this.sendTargetMessage();
            if(this.onvaluechange) this.onvaluechange();
            this.refresh();
            this.lastValue = this.value;
          }
        }     
      },
    
      mousedown : function(e, hit) { if(hit && Interface.mouseDown) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      mousemove : function(e, hit) { if(hit && Interface.mouseDown) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      mouseup   : function(e, hit) { if(hit && Interface.mouseDown) this.changeValue( e.x - this._x(), e.y - this._y() ); },    
    
      touchstart : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      touchmove  : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      touchend   : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },  
    })
    .init( arguments[0] );
  };
  Interface.Slider.prototype = Interface.Widget;

  /**#Interface.Crossfader - Widget
  A horizontal crossfader.

  ## Example Usage##
  `a = new Interface.Crossfader({ bounds:[0,0,1,.2], crossfaderWidth:20 });  
  panel = new Interface.Panel();
  panel.add(a);
  `  
  ## Constructor   
  **param** *properties*: Object. A dictionary of property values (see below) to set for the slider on initialization.
  - - - -
  **/
  /**###Interface.Crossfader.crossfaderWidth : property
  Boolean. The width of the rectangle indicating the current position of the crossfader, in pixel values. TODO: use relative values when used by the panel.
  **/
  Interface.Crossfader = function() {
    Interface.extend(this, {
      type : 'Crossfader',    
      crossfaderWidth: 30,
      serializeMe : ["crossfaderWidth"],
    
      _value : .5,
    
      draw : function() {
        var x = this._x(),
            y = this._y(),
            width = this._width(),
            height= this._height();
          
        this.ctx.fillStyle = this._background();
        this.ctx.fillRect( x, y, width, height );
      
        this.ctx.fillStyle = this._fill();
        this.ctx.fillRect( x + (width - this.crossfaderWidth) * this._value, y, this.crossfaderWidth, height);
      
        this.ctx.strokeStyle = this._stroke();
        this.ctx.strokeRect( x, y, width, height );
      },
    
      changeValue : function( xOffset, yOffset ) {
        if(this.hasFocus || !this.requiresFocus) {
          this._value = xOffset / this._width();
        
          if(this._value < 0) {
            this._value = 0;
            //this.hasFocus = false;
          }else if(this._value > 1) {
            this._value = 1;
            //this.hasFocus = false;
          }
        
          this.value = this.min + (this.max - this.min) * this._value;
                
          if(this.value !== this.lastValue) {
            this.sendTargetMessage();
            if(this.onvaluechange) this.onvaluechange();
            this.refresh();
            this.lastValue = this.value;
          }
        }     
      },
    
      mousedown : function(e) { this.changeValue( e.x - this._x(), e.y - this._y() ); },
      mousemove : function(e) { this.changeValue( e.x - this._x(), e.y - this._y() ); },
      mouseup   : function(e) { this.changeValue( e.x - this._x(), e.y - this._y() ); },
    
      touchstart : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      touchmove  : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      touchend   : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },
    })
    .init( arguments[0] );
  };
  Interface.Crossfader.prototype = Interface.Widget;

  /**#Interface.Button - Widget
  A button with a variety of on/off modes

  ## Example Usage##
  `a = new Interface.Button({ bounds:[0,0,.25,.25], mode:'contact', label:'test' });  
  panel = new Interface.Panel();
  panel.add(a);
  `  
  ## Constructor   
  **param** *properties*: Object. A dictionary of property values (see below) to set for the slider on initialization.
  - - - -
  **/
  /**###Interface.Button.mode : property
  String. Can be 'toggle', 'momentary' or 'contact'. In toggle mode, the button turns on when it is pressed and off when it is pressed again. In momentary mode, the button turns on when pressed and off when released. In contact mode, the button briefly flashes when pressed and sends its value.
  **/
  /**###Interface.Button.label : property
  String. A text label to print in the center of the button.
  **/
  Interface.Button = function() {
    Interface.extend(this, {
      type : 'Button',    
      _value: 0,
      serializeMe : ["mode", "label"],
    
      mode : 'toggle',
      isMouseOver : false,
      isTouchOver : false,
      label : null,
    
      draw : function() {
        var x = this._x(),
            y = this._y(),
            width = this._width(),
            height= this._height();
          
        if(this._value) {
          this.ctx.fillStyle = this._fill();
        }else{
          this.ctx.fillStyle = this._background();  
        }
        this.ctx.fillRect( x, y, width, height );
      
        if(this.label !== null) {
          this.ctx.fillStyle = this._stroke();
          this.ctx.textBaseline = 'middle';
          this.ctx.textAlign = 'center';
          this.ctx.font = this._font();
          this.ctx.fillText(this.label, x + width / 2, y + height / 2);
        }
      
        this.ctx.strokeStyle = this._stroke();
        this.ctx.strokeRect( x, y, width, height );      
      },
    
      changeValue : function( xOffset, yOffset ) {
        if(this.hasFocus || !this.requiresFocus) {
          this._value = !this._value;
        
          this.value = this._value ? this.max : this.min;
                
          if(this.value !== this.lastValue || this.mode === 'contact') {
            this.sendTargetMessage();
            if(this.onvaluechange) this.onvaluechange();
            this.draw();
            this.lastValue = this.value;
          }
        }     
      },
      setValue : function(value, doNotDraw) {
        var r = this.max - this.min,
            v = value;
        
        this.value = value;
                
        if(this.min !== 0 || this.max !== 1) {
          v -= this.min;
          this._value = v / r;
        }else{
          this._value = this.value;
        }
        this.lastValue = this.value;
        if(!doNotDraw && this.mode !== 'contact') this.refresh();
      },

      mousedown : function(e, hit) {
        if(hit && Interface.mouseDown) {
          this.isMouseOver = true;
          this.changeValue();
          if(this.mode === 'contact') {
            var self = this;
            setTimeout( function() { self._value = 0; self.draw(); }, 75);
          }
        }
      },
      mousemove : function(e, hit) { 
        if(!this.requiresFocus && hit && Interface.mouseDown && !this.isMouseOver) {
          this.isMouseOver = true;
          if(this.mode !== 'contact') {
            this.changeValue();// e.x - this.x, e.y - this.y ); 
          }else{
            this._value = 1;
            this.draw();
            var self = this;
            setTimeout( function() { self._value = 0; self.draw(); }, 75);
          }
        }else if(!hit && this.isMouseOver) {
          this.isMouseOver = false;
        }
      },
      mouseup   : function(e) {
        if(this.mode === 'momentary')
          this.changeValue();// e.x - this.x, e.y - this.y ); 
      },
    
      touchstart : function(e, hit) {
        if(hit) {
          this.isTouchOver = true;
          this.changeValue();
          if(this.mode === 'contact') {
            var self = this;
            setTimeout( function() { self._value = 0; self.draw(); }, 75);
          }
        }
      },
      touchmove : function(e, hit) {
        if(!this.requiresFocus && hit && !this.isTouchOver) {
          this.isTouchOver = true;
          if(this.mode !== 'contact') {
            this.changeValue();// e.x - this.x, e.y - this.y );
          
          }else{
            this._value = 1;
            this.draw();
            var self = this;
            setTimeout( function() { self._value = 0; self.draw(); }, 75);
          }
        }else if(!hit && this.isTouchOver) {
          this.isTouchOver = false;
        }
      },
      touchend   : function(e) {
        this.isTouchOver = false;
        if(this.mode === 'momentary')
          this.changeValue();// e.x - this.x, e.y - this.y ); 
      },
    })
    .init( arguments[0] );
  };
  Interface.Button.prototype = Interface.Widget;

  /**#Interface.Knob - Widget
  A virtual knob. Great.

  ## Example Usage##
  `a = new Interface.Knob({ x:.1, y:.1, radius:.3 });  
  panel = new Interface.Panel();
  panel.add(a);
  `  
  ## Constructor   
  **param** *properties*: Object. A dictionary of property values (see below) to set for the slider on initialization.
  - - - -
  **/
  /**###Interface.Knob.radius : property
  Number. The size of the Knob.
  **/
  /**###Interface.Knob.knobBuffer : property
  Number. The size of the space in the middle of the knob.
  **/
  /**###Interface.Knob.centerZero : property
  Number. If true, the knob is centered at zero. Useful for panning knobs.
  **/
  /**###Interface.Knob.usesRotation : property
  Number. If true, the knob value is determined by the slope of the touch or mouse event in relation to the knob. When false, the user simply presses the knob and moves their finger/mouse up and down to change its value.
  **/

  Interface.Knob = function() {  
    Interface.extend(this, {
      type : 'Knob',    
      _value: 0,
      serializeMe : ["usesRotation", "knobBuffer"],
      knobBuffer:3,
      lastPosition: 0,
      usesRotation: true,
    
      draw : function() {
        var x = this._x(),
            y = this._y(),
            width = this._width(),
            height= this._height(),
            radius = width / 2;
          
        this.ctx.clearRect(x, y, radius * 2,radius * 2);
        this.ctx.strokeStyle = this._stroke();
	
      	this.ctx.fillStyle = this._background(); // draw background of widget first
    
        var angle0 = Math.PI * .6;
        var angle1 = Math.PI * .4;

        this.ctx.beginPath();
      
        this.ctx.arc(x + radius, y + radius, radius - this.knobBuffer, angle0, angle1, false);
        this.ctx.arc(x + radius, y + radius, (radius - this.knobBuffer) * .3 , angle1, angle0, true);		
        this.ctx.closePath();
        this.ctx.fill();
          
        this.ctx.fillStyle = this._fill();	// now draw foreground...
	
        if(this.centerZero) {
            var angle3 = Math.PI * 1.5;
            var angle4;
            if(this._value >= .5) {
              angle4 = Math.PI * (1.5 + (this._value - .5) * 1.8); // from 1.5 to 2.4
            }else{
              angle4 = Math.PI * (1.5 - ((1 - this._value * 2) * .9)); // from 1.5 to .6 
            }
            if(this._value > Math.PI * 1.8) this._value -= Math.PI * 1.8; // wrap around      
        
            this.ctx.beginPath();
            this.ctx.arc(x + radius, y + radius, radius -  this.knobBuffer, angle3, angle4, (this._value < .5));
            this.ctx.arc(x + radius, y + radius, (radius - this.knobBuffer) * 0.3,  angle4, angle3, (this._value > .5));
            this.ctx.closePath();
          
            // if(this._value > .495 && this._value < .505) { // draw circle if centered?
            //     this.ctx.beginPath();
            //     this.ctx.arc(this.x + radius , this.y + radius, (radius -  this.knobBuffer) * .3, 0, Math.PI*2, true); 
            //     this.ctx.closePath();
            // }
            this.ctx.fill();
        } else {
            if(!this.isInverted)  { 
              var angle2 = Math.PI * .6 + this._value * 1.8  * Math.PI;
              if(angle2 > 2 * Math.PI) angle2 -= 2 * Math.PI;
            }else{
              var angle2 = Math.PI * (0.4 - (1.8 * this._value));
            }
        
            this.ctx.beginPath();
          
            if(!this.isInverted) {
                this.ctx.arc(x + radius, y + radius, radius - this.knobBuffer, angle0, angle2, false);
                this.ctx.arc(x + radius, y + radius, (radius - this.knobBuffer) * .3, angle2, angle0, true);
            } else {
                this.ctx.arc(x + radius, y + radius, radius - this.knobBuffer, angle1, angle2 ,true);
                this.ctx.arc(x + radius, y + radius, (radius - this.knobBuffer) * .3, angle2, angle1, false);
            }
            this.ctx.closePath();
            this.ctx.fill();
        }
      
        this.ctx.beginPath();
        this.ctx.arc(x + radius, y + radius, radius - this.knobBuffer, angle0, angle1, false);
        this.ctx.arc(x + radius, y + radius, (radius - this.knobBuffer) * .3 , angle1, angle0, true);		
        this.ctx.closePath();
      
        this.ctx.stroke();
      
        if(this.label !== null) {
          this.ctx.fillStyle = this._stroke();
          this.ctx.textBaseline = 'middle';
          this.ctx.textAlign = 'center';
          this.ctx.font = this._font();
          this.ctx.fillText(this.label, x + radius, y + radius * 2.25);
        }
      },
    
      setValue : function(value, doNotDraw) {
        var r = this.max - this.min,
            v = value;
      
        this.lastValue = this.value;
      
        this.value = value;
                
        if(this.min !== 0 || this.max !== 1) {
          v -= this.min;
          this._value = v / r;
        }else{
          this._value = this.value;
        }
      
        if(this.value !== this.lastValue) {
          this.sendTargetMessage();
          if(this.onvaluechange) this.onvaluechange();
          this.refresh();
          this.lastValue = this.value;
        }
      
        if(!doNotDraw) this.refresh();
      },
    
      changeValue : function( xOffset, yOffset ) {
        if(this.hasFocus || !this.requiresFocus) {
          var radius = this._width() / 2;
          this.lastValue = this.value;

          if(!this.usesRotation) {
            if (this.lastPosition != -1) { 
              this._value -= (yOffset - this.lastPosition) / (radius * 2);
            }
          }else{
              var xdiff = radius - xOffset;
              var ydiff = radius - yOffset;
              var angle = Math.PI + Math.atan2(ydiff, xdiff);
              this._value =  ((angle + (Math.PI * 1.5)) % (Math.PI * 2)) / (Math.PI * 2);
            
              if(this.lastRotationValue > .8 && this._value < .2) {
                this._value = 1;
              }else if(this.lastRotationValue < .2 && this._value > .8) {
                this._value = 0;
              }
          }

          if (this._value > 1) this._value = 1;
          if (this._value < 0) this._value = 0;

        	this.lastRotationValue = this._value;
          this.lastPosition = yOffset;
      
          var range  = this.max - this.min;
          this.value = this.min + this._value * range;
      
          if(this.value !== this.lastValue) {
            this.sendTargetMessage();
            if(this.onvaluechange) this.onvaluechange();
            this.refresh();
            this.lastValue = this.value;
          }
        }
      },
    
      hitTest : function(e) {
        if( e.x >= this._x() && e.x < this._x() + this._width() ) {
        	if( e.y >= this._y() && e.y < this._y()  + this._width() ) {  
        		return true;
        	} 
        }
    
        return false;
      },
    
      mousedown : function(e) {
        this.lastPosition = e.y - this._y();
        this.changeValue( e.x - this._x(), e.y - this._y() ); 
      },
      mousemove : function(e) { this.changeValue( e.x - this._x(), e.y - this._y() ); },
      mouseup   : function(e) {},
    
      touchstart : function(e) {
        this.lastPosition = e.y - this._y();
        this.changeValue( e.x - this._x(), e.y - this._y() ); 
      },
      touchmove : function(e) { this.changeValue( e.x - this._x(), e.y - this._y() ); },
      touchend   : function(e) {},
    
      _init : function() {
        var width = this.width,
            height = this.height;
        Object.defineProperty(this, 'width', {
          configurable: true,
          get : function() { return width; },
          set : function(_width) { this.clear(); width = height = _width; this.refresh(); }
        });
        Object.defineProperty(this, 'height', {
          configurable: true,
          get : function() { return height; },
          set : function(_height) { height = _height; }
        });
      },
    })
    .init( arguments[0] );
  };
  Interface.Knob.prototype = Interface.Widget;

  function sign(n) {
    if(n < 0) return -1;
    return 1;
  }
  /**#Interface.XY - Widget
  A multitouch XY controller with optional built-in physics.

  ## Example Usage##
  `a = new Interface.XY({ x:0, y:0, numChildren:2 });  
  panel = new Interface.Panel();
  panel.add(a);
  `  
  ## Constructor   
  **param** *properties*: Object. A dictionary of property values (see below) to set for the slider on initialization.
  - - - -
  **/
  /**###Interface.XY.childWidth : property
  Number. The size of the children, currently in pixels. TODO: use relative values when the panel is using relative sizes and positions.
  **/
  /**###Interface.XY.usePhysics : property
  Boolean. Wheter or not the physics engine should be turned on.
  **/
  /**###Interface.XY.friction : property
  Number. Default .9. The amount of friction in the physics system. High values mean children will decelerate quicker.
  **/
  /**###Interface.XY.maxVelocity : property
  Number. Default 10. The maximum velocity for each child.
  **/
  /**###Interface.XY.detectCollisions : property
  Boolean. Default true. When true, children bounce off one another.
  **/
  /**###Interface.XY.values : property
  Array. An array of objects taking the form {x,y} that store the x and y positions of every child. So, to get the x position of child #0: myXY.values[0].x
  **/
  /**###Interface.XY.children : property
  Array. An array of objects representing the various children of the widget.
  **/
  /**###Interface.XY.animate : method
  This is called to run the physics engine, draw widgets with updated positions, change values of widgets and call appropriate event handlers.
  **/

  Interface.XY = function() {
    var self = this,
        posDiff = {x:0, y:0},
        velDiff = {x:0, y:0},
        normal  = {x:0, y:0},
        cDot = 0;
  
    Interface.extend(this, {
      type : 'XY',    
      _value            : 0,
      serializeMe       : ["childWidth", "childHeight", "numChildren", "usePhysics", "values", "friction", "maxVelocity", "detectCollisions", "fps"],
      childWidth        : 25,
      childHeight       : 25,
      children          : [],
      values            : [],
      numChildren       : 1,
      usePhysics        : true,
      friction          : .9,
      activeTouch       : null,
      maxVelocity       : 10,
      detectCollisions  : true,
      touchCount        : 0,
      timer             : null,
      fps               : 30,
    
      remove: function() { this.stopAnimation(); },
      add : function() { if(this.usePhysics) this.startAnimation(); },
      startAnimation : function() { 
        if(this.timer === null) { 
          this.timer = setInterval( function() { self.refresh(); }, (1 / this.fps) * 1000); 
        } 
      },
      stopAnimation : function() { clearInterval(this.timer); this.timer = null; },
    
      animate : function() {
        var x       = this._x(),
            y       = this._y(),
            width   = this._width(),
            height  = this._height(),
            shouldrunvaluechange = false;
          
        for(var i = 0; i < this.children.length; i++) {
          var moveX = moveY = false,
              child = this.children[i];
        
          if(child.x + child.vx < width && child.x + child.vx > 0) {
            child.x += child.vx;
          }else{  
            if(child.x + child.vx >= width && child.vx > 0 ) {
              child.vx *= -1;
            }else if(child.x + child.vx <= 0 && child.vx < 0) {
              child.vx *= -1;
            }else{
              child.x += child.vx;
            }
          }

          if(child.y + child.vy < height && child.y + child.vy > 0) {
            child.y += child.vy;
          }else{
            if(child.y + child.vy >= height && child.vy > 0 ) {
              child.vy *= -1;
            }else if(child.y + child.vy <= 0 && child.vy < 0) {
              child.vy *= -1;
            }else{
              child.y += child.vy;
            }
          }

          child.vx *= this.friction;
          child.vy *= this.friction;
        
          var newValueX = child.x / width;
          var newValueY = child.y / height;
        
          var range = this.max - this.min;
          if(this.values[child.id].x !== newValueX || this.values[child.id].y !== newValueY) {
            this.values[child.id].x = this.min + range * newValueX;
            this.values[child.id].y = this.min + range * newValueY;
            shouldrunvaluechange = true;
          }
        
          if(this.detectCollisions) {
            if(!child.collideFlag) {
              this.collisionTest(child);
            }else{
              child.collideFlag = false;
            }
          }
          
          child.vx = Math.abs(child.vx) > this.maxVelocity ? this.maxVelocity * sign(child.vx) : child.vx;
          child.vy = Math.abs(child.vy) > this.maxVelocity ? this.maxVelocity * sign(child.vy): child.vy;        
        }
        if(shouldrunvaluechange && this.onvaluechange) {
          this.onvaluechange();
        }
      },
    
      collisionTest : function(c1) {
        var cw2 = (this.childWidth * 2) * (this.childWidth * 2);
        for(var i = 0; i < this.children.length; i++) {
          var c2 = this.children[i];
          if(c1.id !== c2.id) {
            var distance = Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2);
          
            if(distance < cw2) { // avoid square root by raising the distance check
              this.collide(c1, c2)
            }
          }
        }
      },
  
      collide : function(c1,c2) {
        // posDiff, velDiff and normal are upvalues for gc performance
        posDiff.x = c1.x - c2.x;
        posDiff.y = c1.y - c2.y;
        velDiff.x = c1.vx - c2.vx;
        velDiff.y = c1.vy - c2.vy;

        cDot = Math.sqrt( Math.pow(posDiff.x, 2) + Math.pow(posDiff.y, 2) );
            
        normal.x = posDiff.x / cDot;
        normal.y = posDiff.y / cDot;
      
        var d = (normal.x * velDiff.x) + (normal.y * velDiff.y);
        c2.vx = c1.vx + d * normal.x;
        c2.vy = c1.vy + d * normal.y;
        c1.vx = c2.vx - d * normal.x;
        c1.vy = c2.vy - d * normal.y;

        c2.x -= normal.x;
        c2.y -= normal.y;
        c1.x += normal.x;
        c1.y += normal.y;
      
        c1.vx = Math.abs(c1.vx) > this.maxVelocity ? this.maxVelocity * sign(c1.vx) : c1.vx;
        c1.vy = Math.abs(c1.vy) > this.maxVelocity ? this.maxVelocity * sign(c1.vy) : c1.vy;
        c2.vx = Math.abs(c2.vx) > this.maxVelocity ? this.maxVelocity * sign(c2.vx) : c2.vx;
        c2.vy = Math.abs(c2.vy) > this.maxVelocity ? this.maxVelocity * sign(c2.vy) : c2.vy;
      
        c1.collideFlag = true;
        c2.collideFlag = true;         
      },

      draw : function() {
        var x = this._x(),
            y = this._y(),
            width = this._width(),
            height= this._height();
          
        if(this.usePhysics) this.animate();
      
        this.ctx.fillStyle = this._background();
        //this.ctx.fillRect( this.x, this.y, this.width, this.height );
      
        this.ctx.strokeStyle = this._stroke();
        //this.ctx.strokeRect( this.x, this.y, this.width, this.height );
      
        this.ctx.save();
      
        this.ctx.beginPath();
      
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(x + width, y);
        this.ctx.lineTo(x + width, y + height);
        this.ctx.lineTo(x, y + height);
        this.ctx.lineTo(x, y);
        this.ctx.fill();
        this.ctx.stroke();
      
        this.ctx.clip();
      
        this.ctx.fillStyle = this._fill();
      
        for(var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
        
          this.ctx.fillStyle = this._fill();
        
          this.ctx.beginPath();

          this.ctx.arc(x + child.x, y + child.y, this.childWidth, 0, Math.PI*2, true); 

          this.ctx.closePath();
        
          this.ctx.fill();
          this.ctx.stroke();
          //this.ctx.fillRect( this.x + child.x, this.y + child.y, this.childWidth, this.childHeight);
          this.ctx.textBaseline = 'middle';
          this.ctx.textAlign = 'center';
          this.ctx.fillStyle = this._stroke();
          this.ctx.fillText(child.id, x + child.x, y + child.y);
        }
      
        this.ctx.closePath();
        this.ctx.restore();
      },
    
      changeValue : function( touch, xOffset, yOffset ) {
        if(this.hasFocus || !this.requiresFocus) {
          touch.x = xOffset;
          if(touch.x < 0 ) touch.x = 0;
          if(touch.x > this._width()) touch.x = this._width();
                
          touch.y = yOffset;// - this.half;
          if(touch.y < 0) touch.y = 0;
          if(touch.y > this._height()) touch.y = this._height();        
          this.values[touch.id].x = xOffset / this._width();
          this.values[touch.id].y = yOffset / this._height();
                
          if(this.onvaluechange) this.onvaluechange();
        
          if(!this.usePhysics) {
            this.refresh();
          }
        }     
      },
    
      makeChildren : function() {
        for(var i = 0; i < this.numChildren; i++) {
          this.children.push({ id:i, x:Math.random() * this._width(), y:Math.random() * this._height(), vx:0, vy:0, collideFlag:false, isActive:false, lastPosition:null, });
          this.values.push({ x:null, y:null });
        }
      },
    
      touchEvent : function(touch) {
        var isHit = this.hitTest(touch);
        var touchMouseName = convertTouchEvent(touch.type);
      
        if(isHit) {
          if(touch.type === 'touchstart') {
            this.hasFocus = true;
            this.touchCount++;
            this.trackTouch(touch.x - this._x(), touch.y - this._y(), touch);
          }else{
            if(this[touch.type])
              this[touch.type](touch, isHit, touch.childID);  // normal event
          }
        
          if(this['on'+touch.type]) this['on'+touch.type](touch, isHit, touch.childId); // user defined event
          if(this['on'+touchMouseName]) this['on'+touchMouseName](touch, isHit);  // user defined event
        
        }else if(touch.type === 'touchend'){
          this.touchCount--;
          if(this.touchCount === 0) {        
            this.hasFocus = false;
          }else if(this.touchCount < 0 ) {
            this.touchCount = 0;
          }
          this.touchend(touch)
          if(this['on'+touch.type]) this['on'+touch.type](touch, isHit, touch.childId); // user defined event
          if(this['on'+touchMouseName]) this['on'+touchMouseName](touch, isHit);  // user defined event
        }
      },
    
      trackMouse : function(xPos, yPos, id) {
        var closestDiff = 10000;
        var touchFound = null;
        var touchNum = null;
        for(var i = 0; i < this.children.length; i++) {
          var touch = this.children[i];
          var xdiff = Math.abs(touch.x - xPos);
          var ydiff = Math.abs(touch.y - yPos);
        
          if(xdiff + ydiff < closestDiff) {
            closestDiff = xdiff + ydiff;
            
            touchFound = touch;
            touchNum = i;
          }
        }
      
        touchFound.isActive = true;
        touchFound.vx = 0;
        touchFound.vy = 0;
      
        if(touchFound != null) {
          this.changeValue(touchFound, xPos, yPos);
        }
      
        this.activeTouch = touchFound;
        this.activeTouch.lastTouch = null;
      
        this.lastTouched = touchFound;
      },
    
      mousedown : function(e) {
        if(this.hitTest(e)) {
          this.trackMouse(e.x - this._x(), e.y - this._y());
        }
      },
      mousemove : function(e) { 
        if(this.hitTest(e) && this.activeTouch !== null) {
          if(this.activeTouch.lastTouch === null) {
            this.activeTouch.lastTouch = {x:e.x - this._x(), y:e.y - this._y()};
          }else{
            var now = {x:e.x - this._x(), y:e.y - this._y()};
            this.activeTouch.velocity = {x:now.x - this.activeTouch.lastTouch.x, y:now.y - this.activeTouch.lastTouch.y };
            this.activeTouch.lastTouch = now;
          }

          this.changeValue(this.activeTouch, e.x - this._x(), e.y - this._y());
        }
      },
      mouseup   : function(e) {
        if(this.activeTouch !== null) {
          this.activeTouch.vx = this.activeTouch.velocity.x;
          this.activeTouch.vy = this.activeTouch.velocity.y;
          this.activeTouch.lastTouch = null;
          this.activeTouch = null;
        }
        for(var i = 0; i < this.children.length; i++) {
          this.children[i].isActive = false;
        }
      },
    
      trackTouch : function(xPos, yPos, _touch) {
        var closestDiff = 10000;
        var touchFound = null;
        var touchNum = null;
      
        for(var i = 0; i < this.children.length; i++) {
          var touch = this.children[i];
          var xdiff = Math.abs(touch.x - xPos);
          var ydiff = Math.abs(touch.y - yPos);

          if(xdiff + ydiff < closestDiff && !touch.isActive) {
            closestDiff = xdiff + ydiff;
            touchFound = touch;
            touchNum = i;
          }
        }
      
        touchFound.isActive = true;
        touchFound.vx = 0;
        touchFound.vy = 0;
        touchFound.identifier = _touch.identifier;
        touchFound.childID = touchNum;
	
        if(touchFound != null)
          this.changeValue(touchFound, xPos, yPos);
    
        this.lastTouched = touchFound;
        return touchFound.childID;
      },
      touchstart : function(touch) {
        // if(this.hitTest(touch)) {
        //   this.trackTouch(touch.x - this.x, touch.y - this.y, touch);
        // }
      },
      touchmove : function(touch) {
        for(var t = 0; t < this.children.length; t++) {
          _t = this.children[t];
          if(touch.identifier == _t.identifier) {
            this.changeValue(_t, touch.x - this._x(), touch.y - this._y());
			    
            var now = {x:touch.x - this._x(), y:touch.y - this._y()};
          
            if(_t.lastPosition !== null) {
              _t.velocity = {x:now.x - _t.lastPosition.x, y:now.y - _t.lastPosition.y };
            }
            _t.lastPosition = now;
          }
        }
      },
      touchend : function(touch) {
        var found = false;
        var tu = null;
        for(var t = 0; t < this.children.length; t++) {
          var _t = this.children[t];
        
          if(touch.identifier === _t.identifier) {
            _t.vx = _t.velocity.x;
            _t.vy = _t.velocity.y;
          
            _t.lastPosition = null;
            _t.isActive = false;
          

            found = true;
            tu = t.childID;
          }
        }
        if(found) { this.touchUp = tu; }
        //if(!found) console.log("NOT FOUND", touch.identifier);
      },
    
      _init : function() { 
        this.makeChildren();
       },
    })
    .init( arguments[0] );
  
    this.requiresFocus = false; // is a widget default... must set after init.
    this.half = this.childWidth / 2;
  
    var numChildren = this.numChildren;
    Object.defineProperty(this, 'numChildren', {
      get : function() { return numChildren; },
      set : function(_numChildren) { 
        var temp = _numChildren;
        while(_numChildren > numChildren) {
          this.children.push({ id:this.children.length, x:Math.random() * this._width(), y:Math.random() * this._height(), vx:0, vy:0, collideFlag:false, isActive:false, lastPosition:null, });
          this.values.push({ x:null, y: null});
          numChildren++;
        }
      
        while(_numChildren < numChildren) {
          this.chidren.pop();
          this.values.pop();
          numChildren--;
        }
        this.refresh();
        numChildren = _numChildren; 
      }
    });
  };
  Interface.XY.prototype = Interface.Widget;

  /**#Interface.Menu - Widget
  A multi-option dropdown menu.
  ## Example Usage##
  `a = new Interface.Menu({x:0, y:0, options:['red', 'yellow', 'green'] });  
  a.onvaluechange = function() { b.background = this.value; }  
  b = new Interface.Slider({x:.5, y:.5, width:.2, height:.3});  
  panel = new Interface.Panel();  
  panel.add(a,b);
  `  
  ## Constructor   
  **param** *properties*: Object. A dictionary of property values (see below) to set for the slider on initialization.
  - - - -
  **/
  /**###Interface.Menu.options : property
  Array. A list of values found in the menu.
  **/
  /**###Interface.Menu.css : property
  Object. A dictionary of css keys / values to be applied to the menu.
  **/
  /**###Interface.Menu.onvaluechange : method
  The event handler fired whenever the selected menu option changes.  
  
  param **newValue** Number or String. The new menu value.
  param **oldValue** Number or String. The previous menu value.
  **/
  Interface.Menu = function() {
    Interface.extend(this, {
      type : 'Menu',    
      _value: 0,
      serializeMe : ["options", "fontSize"],
      options: [],
      fontSize:15,
      touchEvent: function(e) { // we have to simulate this since the actual event was cancelled to avoid scrolling behavior
        if(this.hitTest(e)) {
          e.stopPropagation();
          /*var evt = document.createEvent('TouchEvent');
          evt.initUIEvent('touchstart', true, true);
        
          evt.view = window;
          evt.screenX = e.screenX;
          evt.screenY = e.screenY;
          evt.clientX = e.clientX;
          evt.clientY = e.clientY; 
          evt.bubbles = false;
          evt.view = window;       
          evt.altKey = false;
          evt.ctrlKey = false;
          evt.shiftKey = false;
          evt.metaKey = false;

          this.element.dispatchEvent(evt);*/
        }
      },
      _init : function() {
        this.element = $("<select>");
      
        for(var i = 0; i < this.options.length; i++) {
         var option = $("<option>" + this.options[i] + "</option>");
         this.element.append(option);
        }
      
        this.element.css({
          position:'absolute',
          backgroundColor:this._background(),
          color:this._stroke(),
          left: this._x() + this.panel.x,
          top:  this._y() + this.panel.y,
          width: this._width(),
          height: this._height(),
          fontSize: this.fontSize,
          display:'block',
          border: '1px solid ' + this._stroke(),
        });
      
        if(this.css) this.element.css( this.css );
      
        var self = this;
        this.element.change( 
          function(obj) {
            var oldValue = self.value;
            self.value = self.element.val();
            self.sendTargetMessage();
            self.onvaluechange(self.value, oldValue);
          }
        );
      
        if(this.options.indexOf( this.value ) !== -1) {
          this.element.val( this.value );
        }else{
          this.element.val( this.options[0] );
        }
        $(this.container).append(this.element);
      },   
    })
    .init( arguments[0] );
  };
  Interface.Menu.prototype = Interface.Widget;

  Interface.Label = function() {
    Interface.extend(this, {
      type : 'Label',    
      serializeMe : ["size", "style", "hAlign", "vAlign", "font"],
      size:12,
      style:'normal',
      hAlign:'center',
      vAlign:'top',
      font : 'sans-serif',
    
      draw : function() {
        this.ctx.font = this.style + ' ' + this.size + 'px ' + this.font;
        this.ctx.textAlign = this.hAlign;
        this.ctx.textBaseline = this.vAlign;
      
        var metrics = this.ctx.measureText(this.lastValue),
            rect = {
              x: 0,
              y: this._y() - this.size / 2,
              width: metrics.width,
              height: this.size,
            };
      
        var x, y;
        switch(this.hAlign) {
          case 'center':
            x = (this._x() + this._width() / 2)
            rect.x = x - metrics.width / 2;
            break;
          case 'left':
            x = this._x();
            rect.x = x;
            break; 
          case 'right':
            x = this._x() + this._width();
            rect.x =  x - metrics.width;
            break;
        }
        switch(this.vAlign) {
          case 'middle':
            y = (this._y() + this._height() / 2)
            rect.y = y - metrics.height / 2;
            break;
          case 'top':
            y = this._y();
            rect.y = y;
            break; 
          case 'bottom':
            y = this._y() + this._height();
            rect.y =  y - metrics.height;
            break;
        }
        this.ctx.clearRect(rect.x, rect.y, rect.width, rect.height * 2);      
      
        this.ctx.save();
      
        this.ctx.beginPath();
      
        this.ctx.moveTo(this._x(), this._y());
        this.ctx.lineTo(this._x() + this._width(), this._y());
        this.ctx.lineTo(this._x() + this._width(), this._y() + this._height());
        this.ctx.lineTo(this._x(), this._y() + this._height());
        this.ctx.lineTo(this._x(), this._y());
        this.ctx.closePath();
      
        this.ctx.clip();

        this.ctx.fillStyle = this._stroke();
        this.ctx.fillText(this.value, x, y);
      
        this.ctx.restore();
        this.lastValue = this.value;
      },
    })
    .init( arguments[0] );
    this.lastValue = this.value;
  };
  Interface.Label.prototype = Interface.Widget;

  Interface.TextField = function() {
    Interface.extend(this, {
      type : 'TextField',    
      serializeMe : ["fontSize"],
      fontSize: 15, 
      touchEvent: function(e) { // we have to simulate this since the actual event was cancelled to avoid scrolling behavior
        if(this.hitTest(e)) {
          var evt = document.createEvent('TouchEvent');
          evt.initUIEvent('touchstart', true, true);
        
          evt.view = window;
          evt.screenX = e.screenX;
          evt.screenY = e.screenY;
          evt.clientX = e.clientX;
          evt.clientY = e.clientY; 
          evt.bubbles = false;
          evt.view = window;       
          evt.altKey = false;
          evt.ctrlKey = false;
          evt.shiftKey = false;
          evt.metaKey = false;

          this.element.dispatchEvent(evt);
        }
      },
      _init : function() {
        this.element = $("<input>");
      
        if(this.value !== 0) {
          this.element.val( this.value );
        }
        this.element.css({
          position:'absolute',
          backgroundColor:this._background(),
          color:this._fill(),
          left: this._x() + this.panel.x,
          top:  this._y() + this.panel.y,
          width: this._width(),
          height: this._height(),
          fontSize: this.fontSize,
          display:'block',
          border: '1px solid ' + this._stroke(),
        });
      
        if(this.css) this.element.css( this.css );
      
        var self = this;
        this.element.change( 
          function(obj) {
            var oldValue = self.value;
            self.value = self.element.val();
            self.sendTargetMessage();
            self.onvaluechange(self.value, oldValue);
          }
        );
      
        $(this.container).append(this.element);
      },   
    })
    .init( arguments[0] );
  };
  Interface.TextField.prototype = Interface.Widget;

  Interface.MultiSlider = function() {
    Interface.extend(this, {
      type : 'MultiSlider',    
      isVertical : true,
      serializeMe : ["isVertical", "count", "values"],
      values: [],
      _values: [],
      count:16,

      draw : function() {
        var x = this._x(),
            y = this._y(),
            width = this._width(),
            height= this._height(),
            sliderWidth = width / this.count;
          
        this.ctx.fillStyle = this._background();
        this.ctx.fillRect( x, y, width, height );
      
        this.ctx.fillStyle = this._fill();
        this.ctx.strokeStyle = this._stroke();
            
        for(var i = 0; i < this.count; i++) {
          var sliderX = i * sliderWidth + x;

          this.ctx.fillRect( sliderX, y + height - this._values[i] * height, sliderWidth, this._values[i] * height);
          this.ctx.strokeRect( sliderX, y, sliderWidth, height );         
        }      
      },

      changeValue : function( xOffset, yOffset ) {
        if(this.hasFocus || !this.requiresFocus) {
          var width   = this._width(),
              sliderWidth = width / this.count,
              sliderHit = Math.floor( xOffset / sliderWidth )
              _value = 0;
        
          _value = 1 - ( yOffset / this._height() );
        
          if(_value < 0) {
            _value = 0;
            // this.hasFocus = false;
          }else if(_value > 1) {
            _value = 1;
            // this.hasFocus = false;
          }
        
          this.values[ sliderHit ] = this.min + (this.max - this.min) * _value;
          this._values[ sliderHit ] = _value;
        
          //if(this.value !== this.lastValue) {
          this.sendTargetMessage();
          if(this.onvaluechange) this.onvaluechange(sliderHit, this.values[ sliderHit ]);
          this.refresh();
            //this.lastValue = this.value;
            //}
        }     
      },
    
      mousedown : function(e, hit) { if(hit && Interface.mouseDown) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      mousemove : function(e, hit) { if(hit && Interface.mouseDown) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      mouseup   : function(e, hit) { if(hit && Interface.mouseDown) this.changeValue( e.x - this._x(), e.y - this._y() ); },    
    
      touchstart : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      touchmove  : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      touchend   : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },  
      onvaluechange : function(id, value) {},
    })
    .init( arguments[0] );
  
    var x = this.x,
        y = this.y,
        width = this.width,
        height = this.height,
        bounds = [x,y,width,height],
        count = this.count;
  
    delete this.bounds;

    Object.defineProperties(this, {
      x : {
        get : function() { return x; },
        set: function(_x) { x = _x; this.refresh(); }
      },
      y : {
        get : function() { return y; },
        set: function(_y) { y = _y; this.refresh(); }
      },
      width : {
        get : function() { return width; },
        set: function(_width) { width = _width; this.refresh(); }
      },
      height : {
        get : function() { return height; },
        set: function(_height) { height = _height; this.refresh(); }
      },    
      bounds : {
        get : function() { return bounds; },
        set : function(_bounds) { bounds = _bounds; x = bounds[0]; y = bounds[1]; width = bounds[2]; height = bounds[3]; this.refresh(); }
      },
      count : {
        get : function() { return count; },
        set : function(_count) { count = _count; this.refresh(); },
      }
    })
  };
  Interface.MultiSlider.prototype = Interface.Widget;

  Interface.MultiButton = function() {
    Interface.extend(this, {
      type : 'MultiButton',    
      mode : 'toggle',
      serializeMe : ["mode", "rows", "columns", "requiresFocus"],
      rows:     8,
      values: [],
      _values: [],
      lastValues: [],
      mouseOver : null,
      columns:  8,
    
      draw : function() { 
        var x = this._x(),
            y = this._y(),
            width = this._width(),
            height= this._height(),
            childWidth  = width  / this.columns,
            childHeight = height / this.rows;   
      
        this.ctx.strokeStyle = this._stroke();
        
        for(var i = 0; i < this.rows; i++) {
          for(var j = 0; j < this.columns; j++) {
            var _x = x + j * childWidth,
                _y = y + i * childHeight,
                btn = i * this.columns + j;              
 
            if(this._values[ btn ]) {
              this.ctx.fillStyle = this._fill();
            }else{
              this.ctx.fillStyle = this._background();  
            }
            this.ctx.fillRect( _x, _y, childWidth, childHeight );
            this.ctx.strokeRect( _x, _y, childWidth, childHeight );          
          }
        }
      },
    
      changeValue : function( xOffset, yOffset ) {
        if(this.hasFocus || !this.requiresFocus) {
          var width   = this._width(),
              height  = this._height(),
              buttonWidth = width / this.columns,
              columnHit = Math.floor( xOffset / buttonWidth ),
              buttonHeight = height / this.rows,
              rowHit = Math.floor( yOffset / buttonHeight),
              buttonHit = (rowHit * this.columns) + columnHit,
              _value = 0;
        
        
          if( buttonHit !== this.mouseOver ) {
            this._values[ buttonHit ] = !this._values[ buttonHit ];
        
            this.values[ buttonHit ] = this._values[ buttonHit ] ? this.max : this.min;
                
            if(this.values[ buttonHit ] !== this.lastValues[ buttonHit ] || this.mode === 'contact') {
              this.sendTargetMessage();
              if(this.onvaluechange) this.onvaluechange( rowHit, columnHit, this.values[ buttonHit ]);

              this.draw();
              this.lastValues[ buttonHit ] = this.values[ buttonHit ];
            
              if(this.mode === 'contact') {
                var self = this;
                setTimeout( function() { self._values[ buttonHit ] = 0; self.draw(); }, 75);
              }
            }
          
            this.mouseOver = buttonHit;
          }
        }
      },
    
      mousedown : function(e, hit) { 
        if(hit && Interface.mouseDown) { 
          this.changeValue( e.x - this._x(), e.y - this._y() );
        }
      },
      mousemove : function(e, hit) { 
        if(hit && Interface.mouseDown) {  
          this.changeValue( e.x - this._x(), e.y - this._y() );
        }
      },
      mouseup   : function(e, hit) { 
        if(hit && Interface.mouseDown) this.changeValue( e.x - this._x(), e.y - this._y() ); 
        this.mouseOver = null;
      },    
    
      touchstart : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      touchmove  : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      touchend   : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); }, 
    })
    .init( arguments[0] );
  
    this.requiresFocus = false;
    var x = this.x,
        y = this.y,
        width = this.width,
        height = this.height,
        bounds = [x,y,width,height]
        rows = this.rows,
        columns = this.columns;
  
    delete this.bounds;

    Object.defineProperties(this, {
      x : {
        get : function() { return x; },
        set: function(_x) { x = _x; this.refresh(); }
      },
      y : {
        get : function() { return y; },
        set: function(_y) { y = _y; this.refresh(); }
      },
      width : {
        get : function() { return width; },
        set: function(_width) { width = _width; this.refresh(); }
      },
      height : {
        get : function() { return height; },
        set: function(_height) { height = _height; this.refresh(); }
      },    
      bounds : {
        get : function() { return bounds; },
        set : function(_bounds) { bounds = _bounds; x = bounds[0]; y = bounds[1]; width = bounds[2]; height = bounds[3]; this.refresh(); }
      },
      rows : {
        get : function() { return rows; },
        set : function(_rows) { rows = _rows; this.refresh(); },
      },
      columns : {
        get : function() { return columns; },
        set : function(_columns) { columns = _columns; this.refresh(); },
      },
    });
  };
  Interface.MultiButton.prototype = Interface.Widget;

  Interface.Accelerometer = function() {
    var self = this,
        metersPerSecondSquared = 9.80665;
  
    Interface.extend(this, {
      type:"Accelerometer",
    
      serializeMe : ["delay"],
      delay : 100, // measured in ms
      min: 0,
      max: 1,

      update : function(event) {
        var acceleration = event.acceleration;
        self.x = self.min + ((((0 - self.hardwareMin) + acceleration.x) / self.hardwareRange ) * self.max);
        self.y = self.min + ((((0 - self.hardwareMin) + acceleration.y) / self.hardwareRange ) * self.max);
        self.z = self.min + ((((0 - self.hardwareMin) + acceleration.z) / self.hardwareRange ) * self.max);
        
        if(typeof self.onvaluechange !== 'undefined') {
          self.onvaluechange(self.x, self.y, self.z);
        }
      },
      start : function() {
        window.addEventListener('devicemotion', this.update, true);
        return this;
      },
      stop : function() {
        window.removeEventListener('devicemotion', this.update);
        return this;
      },
    })
    .init( arguments[0] );
    
  	if(!Interface.isAndroid) {
  	    this.hardwareMin = -2.307 * metersPerSecondSquared;  // as found here: http://www.iphonedevsdk.com/forum/iphone-sdk-development/4822-maximum-accelerometer-reading.html
  	    this.hardwareMax = 2.307 * metersPerSecondSquared;   // -1 to 1 works much better for devices without gyros to measure tilt, -2 to 2 much better to measure force
  	}else{
  	    this.hardwareMin = metersPerSecondSquared;
  	    this.hardwareMax = metersPerSecondSquared;
  	}
    
    this.hardwareRange = this.hardwareMax - this.hardwareMin;
  };
  Interface.Accelerometer.prototype = Interface.Widget;

  Interface.Orientation = function() {
    var _self = this;
  
    Interface.extend(this, {
      type:"Orientation",
      serializeMe : ["delay"],
      delay : 100, // measured in ms
      update : function(orientation) {
        _self.roll   = _self.min + ((90 + orientation.gamma)  /  180 ) * _self.max ;
        _self.pitch  = _self.min + ((180 + orientation.beta) / 360 ) * _self.max ;
        _self.yaw    = _self.min + (orientation.alpha / 360 ) * _self.max ;
      
        if( !isNaN(orientation.webkitCompassHeading) ) {
          _self.heading = _self.min + ((orientation.webkitCompassHeading  /  360 ) * _self.max );
        }
      
        _self.sendTargetMessage();
      
        if(typeof _self.onvaluechange !== 'undefined') {
          _self.onvaluechange(_self.pitch, _self.roll, _self.yaw, _self.heading);
        }
      },
      start : function() {
        window.addEventListener('deviceorientation', function (event) {
          _self.update(event);
        }, true);
        return this;
      },
      stop : function() {
        window.removeEventListener('deviceorientation');
      },
    })
    .init( arguments[0] );
  };
  Interface.Orientation.prototype = Interface.Widget;

  Interface.Range = function() {
    Interface.extend(this, {
      type:"Range",
      serializeMe : ["handleSize"],    
      handleSize: 20,
      values:[0,1],
      _values:[0,1],
      draw : function() {
        var x = this._x(),
            y = this._y(),
            width = this._width(),
            height= this._height();
          
        this.ctx.fillStyle = this._background();
        this.ctx.clearRect(x, y, width, height);    
        
    		var rightHandlePos = x + (this._values[1] * width) - this.handleSize;
    		var leftHandlePos  = x + this._values[0]  * width;
		    
  	    this.ctx.fillStyle = this._background();
        this.ctx.fillRect(x, y, width, height);
        
  	    this.ctx.fillStyle = this._fill();
        this.ctx.fillRect(leftHandlePos, y, rightHandlePos - leftHandlePos, height);
		
  	    this.ctx.fillStyle = this._stroke();
    		this.ctx.fillRect(leftHandlePos, y, this.handleSize, height);
		
  	    //this.ctx.fillStyle = "rgba(0,255,0,.25)";
    		this.ctx.fillRect(rightHandlePos, y, this.handleSize, height);
      
        this.ctx.strokeStyle = this._stroke();
        this.ctx.strokeRect(x, y, width, height);    
      },
      changeValue : function( xOffset, yOffset ) {
        if(this.hasFocus || !this.requiresFocus) {
          var value = this.isVertical ? 1 - (yOffset / this._height()) : xOffset / this._width();
        
          if(value < 0) {
            value = 0;
          }else if(value > 1) {
            value = 1;
          }

          var range = this.max - this.min
        	if(Math.abs( value - this._values[0]) < Math.abs( value - this._values[1])) {
            this._values[0] = value;
        		this.values[0] = this.min + range * value;
        	}else{
            this._values[1] = value;
        		this.values[1] = this.min + range * value;
        	}
        
          this.refresh();
        
          if(this.values[0] !== this.lastLeftValue || this.values[1] !== this.lastRightValue) {
            if(this.onvaluechange) this.onvaluechange(this.values[0], this.values[1]);
            this.refresh();
            this.lastLeftValue = this.values[0];
            this.lastRightValue = this.values[1];          
          }
        }     
      },
    
      mousedown : function(e, hit) { if(hit && Interface.mouseDown) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      mousemove : function(e, hit) { if(hit && Interface.mouseDown) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      mouseup   : function(e, hit) { if(hit && Interface.mouseDown) this.changeValue( e.x - this._x(), e.y - this._y() ); },    
    
      touchstart : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      touchmove  : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },
      touchend   : function(e, hit) { if(hit) this.changeValue( e.x - this._x(), e.y - this._y() ); },  
    })
    .init( arguments[0] );
  }
  Interface.Range.prototype = Interface.Widget;

  Interface.defineChildProperties = function(widget, properties) {
    for(var j = 0; j < properties.length; j++) {
      (function() {
        var key = properties[j];
        var val = widget[key]
        Object.defineProperty(widget, key, {
          get: function() { return val; },
          set: function(_val) {
            val = _val;
            for(var i = 0; i < widget.children.length; i++) {
              widget.children[i][key] = val;
            }
          }
        });
      })();
    }
  };
  </script>
  
</head>
<body>
  <script>
    // place your script here
  </script>
</body>

</html>